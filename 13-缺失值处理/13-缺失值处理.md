# 第13章：缺失值处理（高级）

本章将深入探讨Pandas中缺失值处理的高级技巧，包括不同类型的缺失值、高级填充策略、以及在实际项目中的最佳实践。

## 13.1 缺失值的类型

```python
import pandas as pd
import numpy as np

# Pandas中的缺失值表示
print("Pandas缺失值类型：")
print(f"1. np.nan (Not a Number): {np.nan}")
print(f"2. pd.NA (Pandas NA): {pd.NA}")
print(f"3. pd.NaT (Not a Time): {pd.NaT}")
print(f"4. None: {None}")

# 不同类型数据的缺失值
df = pd.DataFrame({
    'float': [1.0, np.nan, 3.0],
    'int_nullable': pd.array([1, pd.NA, 3], dtype='Int64'),
    'string': pd.array(['a', pd.NA, 'c'], dtype='string'),
    'datetime': pd.to_datetime(['2024-01-01', pd.NaT, '2024-01-03']),
    'object': ['x', None, 'z']
})

print("\n不同类型的缺失值：")
print(df)
print("\n数据类型：")
print(df.dtypes)
print("\n缺失值检测：")
print(df.isna())
```

## 13.2 高级填充策略

### 13.2.1 插值方法详解

```python
# 创建带缺失值的时间序列
dates = pd.date_range('2024-01-01', periods=20)
values = [10, 15, np.nan, np.nan, 25, 30, np.nan, 40, 45, np.nan,
          50, np.nan, np.nan, 60, 65, np.nan, 70, 75, np.nan, 85]
ts = pd.Series(values, index=dates)

print("原始数据：")
print(ts)

# 线性插值
print("\n线性插值：")
print(ts.interpolate(method='linear'))

# 时间插值
print("\n时间加权插值：")
print(ts.interpolate(method='time'))

# 多项式插值
print("\n多项式插值（2次）：")
print(ts.interpolate(method='polynomial', order=2))

# 样条插值
print("\n样条插值：")
print(ts.interpolate(method='spline', order=3))

# 前向/后向填充限制
print("\n前向填充（最多填充2个）：")
print(ts.fillna(method='ffill', limit=2))
```

### 13.2.2 基于分组的填充

```python
# 创建分组数据
df = pd.DataFrame({
    'Category': ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'],
    'Value': [10, np.nan, 30, np.nan, 50, 60, 70, np.nan, 90]
})

print("原始数据：")
print(df)

# 用组内均值填充
df['Value_Mean'] = df.groupby('Category')['Value'].transform(lambda x: x.fillna(x.mean()))
print("\n用组内均值填充：")
print(df)

# 用组内中位数填充
df['Value_Median'] = df.groupby('Category')['Value'].transform(lambda x: x.fillna(x.median()))
print("\n用组内中位数填充：")
print(df)

# 用组内前向填充
df['Value_FFill'] = df.groupby('Category')['Value'].transform(lambda x: x.fillna(method='ffill'))
print("\n用组内前向填充：")
print(df)
```

### 13.2.3 使用机器学习填充

```python
# 使用K最近邻填充（需要sklearn）
from sklearn.impute import KNNImputer

# 创建数据
df_ml = pd.DataFrame({
    'Feature1': [1, 2, np.nan, 4, 5],
    'Feature2': [10, np.nan, 30, 40, 50],
    'Feature3': [100, 200, 300, np.nan, 500]
})

print("原始数据：")
print(df_ml)

# KNN填充
imputer = KNNImputer(n_neighbors=2)
df_knn = pd.DataFrame(
    imputer.fit_transform(df_ml),
    columns=df_ml.columns
)
print("\nKNN填充后：")
print(df_knn)
```

## 13.3 缺失模式分析

```python
import matplotlib.pyplot as plt

# 创建数据
np.random.seed(42)
df_missing = pd.DataFrame({
    'A': np.random.randn(100),
    'B': np.random.randn(100),
    'C': np.random.randn(100),
    'D': np.random.randn(100)
})

# 随机插入缺失值
for col in df_missing.columns:
    df_missing.loc[np.random.choice(df_missing.index, 20, replace=False), col] = np.nan

print("缺失值统计：")
print(df_missing.isnull().sum())

# 缺失值百分比
missing_pct = (df_missing.isnull().sum() / len(df_missing) * 100).sort_values(ascending=False)
print("\n缺失值百分比：")
print(missing_pct)

# 缺失值模式
print("\n缺失值模式（前10行）：")
print(df_missing.isnull().astype(int).head(10))

# 缺失值相关性
missing_corr = df_missing.isnull().corr()
print("\n缺失值相关性：")
print(missing_corr)
```

## 13.4 处理策略选择

```python
def analyze_missing_strategy(df, column):
    """分析列的缺失值并推荐处理策略"""

    missing_count = df[column].isnull().sum()
    missing_pct = missing_count / len(df) * 100

    print(f"\n列 '{column}' 的缺失值分析：")
    print(f"缺失值数量: {missing_count}")
    print(f"缺失值百分比: {missing_pct:.2f}%")

    if missing_pct == 0:
        print("建议: 无需处理")
    elif missing_pct < 5:
        print("建议: 可以删除或填充")
    elif missing_pct < 30:
        print("建议: 使用填充方法（均值/中位数/插值）")
    else:
        print("建议: 考虑删除该列或使用高级填充方法")

    # 数据分布
    if pd.api.types.is_numeric_dtype(df[column]):
        print(f"\n描述统计:")
        print(df[column].describe())

# 测试
df_test = pd.DataFrame({
    'Low_Missing': [1, 2, np.nan, 4, 5, 6, 7, 8, 9, 10],
    'Medium_Missing': [1, np.nan, 3, np.nan, 5, np.nan, 7, 8, 9, 10],
    'High_Missing': [1, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, 8, 9, 10]
})

for col in df_test.columns:
    analyze_missing_strategy(df_test, col)
```

## 13.5 最佳实践

```python
# 综合案例：智能处理缺失值
def smart_fill_missing(df, strategy='auto'):
    """智能填充缺失值"""

    df_filled = df.copy()

    for col in df.columns:
        if df[col].isnull().sum() == 0:
            continue

        missing_pct = df[col].isnull().sum() / len(df) * 100

        # 根据缺失比例和数据类型选择策略
        if missing_pct > 50:
            print(f"{col}: 缺失超过50%，跳过")
            continue

        if pd.api.types.is_numeric_dtype(df[col]):
            # 数值型：使用中位数
            df_filled[col] = df[col].fillna(df[col].median())
            print(f"{col}: 用中位数 {df[col].median():.2f} 填充")

        elif pd.api.types.is_datetime64_any_dtype(df[col]):
            # 日期型：前向填充
            df_filled[col] = df[col].fillna(method='ffill')
            print(f"{col}: 用前向填充")

        else:
            # 分类型：用众数
            mode_value = df[col].mode()[0] if len(df[col].mode()) > 0 else 'Unknown'
            df_filled[col] = df[col].fillna(mode_value)
            print(f"{col}: 用众数 '{mode_value}' 填充")

    return df_filled

# 测试
df_example = pd.DataFrame({
    'Age': [25, 30, np.nan, 35, np.nan],
    'Salary': [5000, np.nan, 7000, np.nan, 9000],
    'City': ['Beijing', 'Shanghai', np.nan, 'Beijing', 'Shanghai'],
    'Date': pd.to_datetime(['2024-01-01', pd.NaT, '2024-01-03', '2024-01-04', pd.NaT])
})

print("原始数据：")
print(df_example)
print("\n智能填充：")
df_result = smart_fill_missing(df_example)
print(df_result)
```

*(继续在下一个文件中)*
