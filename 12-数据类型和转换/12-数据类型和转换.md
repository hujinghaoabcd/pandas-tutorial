# 第12章：数据类型和转换

理解和正确使用数据类型是高效数据处理的关键。Pandas提供了丰富的数据类型和转换方法。本章将详细介绍Pandas中的数据类型系统和转换技术。

## 12.1 Pandas数据类型

### 12.1.1 基本数据类型

```python
import pandas as pd
import numpy as np

# 创建包含不同数据类型的DataFrame
df = pd.DataFrame({
    'Integer': [1, 2, 3, 4, 5],
    'Float': [1.1, 2.2, 3.3, 4.4, 5.5],
    'String': ['a', 'b', 'c', 'd', 'e'],
    'Boolean': [True, False, True, False, True],
    'Datetime': pd.date_range('2024-01-01', periods=5),
    'Category': pd.Categorical(['A', 'B', 'A', 'C', 'B'])
})

print("DataFrame及其数据类型：")
print(df)
print("\n数据类型：")
print(df.dtypes)

# 查看内存使用
print("\n内存使用：")
print(df.memory_usage(deep=True))
```

### 12.1.2 数值类型

```python
# 整数类型
int_types = pd.DataFrame({
    'int8': pd.array([1, 2, 3], dtype='int8'),
    'int16': pd.array([1, 2, 3], dtype='int16'),
    'int32': pd.array([1, 2, 3], dtype='int32'),
    'int64': pd.array([1, 2, 3], dtype='int64')
})

print("整数类型：")
print(int_types.dtypes)

# 浮点类型
float_types = pd.DataFrame({
    'float32': pd.array([1.1, 2.2, 3.3], dtype='float32'),
    'float64': pd.array([1.1, 2.2, 3.3], dtype='float64')
})

print("\n浮点类型：")
print(float_types.dtypes)

# 无符号整数
uint_types = pd.DataFrame({
    'uint8': pd.array([1, 2, 3], dtype='uint8'),
    'uint16': pd.array([1, 2, 3], dtype='uint16'),
    'uint32': pd.array([1, 2, 3], dtype='uint32'),
    'uint64': pd.array([1, 2, 3], dtype='uint64')
})

print("\n无符号整数类型：")
print(uint_types.dtypes)
```

## 12.2 类别数据（Categorical）

### 12.2.1 创建类别数据

```python
# 创建类别数据
cat = pd.Categorical(['A', 'B', 'C', 'A', 'B', 'C'])
print("类别数据：")
print(cat)
print("类别：", cat.categories)
print("编码：", cat.codes)

# 从Series创建
s = pd.Series(['Low', 'Medium', 'High', 'Low', 'High', 'Medium'])
cat_series = s.astype('category')
print("\n类别Series：")
print(cat_series)
print("数据类型：", cat_series.dtype)

# 有序类别
cat_ordered = pd.Categorical(['Low', 'Medium', 'High', 'Low', 'High'],
                             categories=['Low', 'Medium', 'High'],
                             ordered=True)
print("\n有序类别：")
print(cat_ordered)
print("是否有序：", cat_ordered.ordered)
```

### 12.2.2 类别数据的优势

```python
# 内存比较
n = 100000
string_data = pd.Series(np.random.choice(['A', 'B', 'C', 'D', 'E'], n))
categorical_data = string_data.astype('category')

print("字符串数据内存使用：", string_data.memory_usage(deep=True))
print("类别数据内存使用：", categorical_data.memory_usage(deep=True))
print(f"节省内存：{(1 - categorical_data.memory_usage(deep=True) / string_data.memory_usage(deep=True)) * 100:.1f}%")

# 性能比较
import time

# 字符串分组
start = time.time()
string_grouped = string_data.groupby(string_data).size()
string_time = time.time() - start

# 类别分组
start = time.time()
cat_grouped = categorical_data.groupby(categorical_data).size()
cat_time = time.time() - start

print(f"\n字符串分组时间：{string_time:.4f}秒")
print(f"类别分组时间：{cat_time:.4f}秒")
print(f"加速比：{string_time/cat_time:.2f}x")
```

### 12.2.3 类别操作

```python
# 创建类别Series
cat = pd.Series(['A', 'B', 'C', 'A', 'B'], dtype='category')
print("原始类别：")
print(cat.cat.categories)

# 重命名类别
cat_renamed = cat.cat.rename_categories({'A': 'Alpha', 'B': 'Beta', 'C': 'Gamma'})
print("\n重命名后：")
print(cat_renamed)

# 添加类别
cat_added = cat.cat.add_categories(['D', 'E'])
print("\n添加类别后：")
print(cat_added.cat.categories)

# 删除未使用的类别
cat_with_unused = pd.Series(['A', 'B', 'A'], dtype=pd.CategoricalDtype(categories=['A', 'B', 'C', 'D']))
print("\n删除未使用类别前：")
print(cat_with_unused.cat.categories)
cat_cleaned = cat_with_unused.cat.remove_unused_categories()
print("删除未使用类别后：")
print(cat_cleaned.cat.categories)

# 设置有序
cat_unordered = pd.Series(['Low', 'High', 'Medium'], dtype='category')
cat_ordered = cat_unordered.cat.reorder_categories(['Low', 'Medium', 'High'], ordered=True)
print("\n设置有序后：")
print(cat_ordered)
print("可以比较：", cat_ordered[0] < cat_ordered[1])
```

## 12.3 日期时间类型

### 12.3.1 datetime64类型

```python
# 创建datetime数据
dates = pd.date_range('2024-01-01', periods=10, freq='D')
df_dates = pd.DataFrame({
    'Date': dates,
    'Value': np.random.randn(10)
})

print("日期时间数据：")
print(df_dates)
print("\n数据类型：")
print(df_dates.dtypes)

# 访问日期时间属性
df_dates['Year'] = df_dates['Date'].dt.year
df_dates['Month'] = df_dates['Date'].dt.month
df_dates['Day'] = df_dates['Date'].dt.day
df_dates['DayOfWeek'] = df_dates['Date'].dt.dayofweek
df_dates['DayName'] = df_dates['Date'].dt.day_name()

print("\n提取日期组件：")
print(df_dates[['Date', 'Year', 'Month', 'Day', 'DayOfWeek', 'DayName']].head())
```

### 12.3.2 timedelta64类型

```python
# 创建timedelta
td = pd.Timedelta('1 days 2 hours 30 minutes')
print("时间间隔：", td)

# timedelta Series
dates = pd.date_range('2024-01-01', periods=5)
df = pd.DataFrame({'Start': dates})
df['End'] = df['Start'] + pd.Timedelta('2 days')
df['Duration'] = df['End'] - df['Start']

print("\n时间间隔数据：")
print(df)
print("\nDuration数据类型：", df['Duration'].dtype)
```

### 12.3.3 Period类型

```python
# 创建Period
period = pd.Period('2024-01', freq='M')
print("周期：", period)

# Period范围
periods = pd.period_range('2024-01', periods=12, freq='M')
print("\n周期范围：")
print(periods)

# Period DataFrame
df_period = pd.DataFrame({
    'Period': periods,
    'Value': np.random.randn(12)
})
print("\n周期DataFrame：")
print(df_period.head())
```

## 12.4 类型转换

### 12.4.1 astype()方法

```python
# 创建数据
df = pd.DataFrame({
    'A': ['1', '2', '3', '4', '5'],
    'B': [1.1, 2.2, 3.3, 4.4, 5.5],
    'C': [True, False, True, False, True]
})

print("原始数据类型：")
print(df.dtypes)

# 转换单列
df['A'] = df['A'].astype(int)
print("\n转换A列为整数后：")
print(df.dtypes)

# 转换多列
df = df.astype({'B': int, 'C': str})
print("\n转换B和C列后：")
print(df.dtypes)
print(df)
```

### 12.4.2 to_numeric()

```python
# 创建包含非数字的数据
s = pd.Series(['1', '2', 'abc', '4', '5'])

# 默认行为（报错）
try:
    result = pd.to_numeric(s)
except ValueError as e:
    print(f"转换错误: {e}")

# 强制转换（无效值变为NaN）
result = pd.to_numeric(s, errors='coerce')
print("\nerrors='coerce':")
print(result)

# 忽略错误（保持原样）
result = pd.to_numeric(s, errors='ignore')
print("\nerrors='ignore':")
print(result)

# 向下转型
s_large = pd.Series([1, 2, 3, 4, 5], dtype='int64')
s_small = pd.to_numeric(s_large, downcast='integer')
print("\n向下转型:")
print(f"原类型: {s_large.dtype}, 新类型: {s_small.dtype}")
```

### 12.4.3 to_datetime()

```python
# 字符串转日期
dates_str = pd.Series(['2024-01-01', '2024-01-02', '2024-01-03'])
dates = pd.to_datetime(dates_str)
print("字符串转日期：")
print(dates)

# 不同格式
dates_various = pd.Series(['01/01/2024', '02/01/2024', '03/01/2024'])
dates = pd.to_datetime(dates_various, format='%d/%m/%Y')
print("\n自定义格式转换：")
print(dates)

# 处理无效日期
dates_invalid = pd.Series(['2024-01-01', 'invalid', '2024-01-03'])
dates = pd.to_datetime(dates_invalid, errors='coerce')
print("\n处理无效日期：")
print(dates)

# 从多列组合
df = pd.DataFrame({
    'year': [2024, 2024, 2024],
    'month': [1, 2, 3],
    'day': [15, 20, 25]
})
dates = pd.to_datetime(df)
print("\n从多列组合：")
print(dates)
```

### 12.4.4 to_timedelta()

```python
# 字符串转timedelta
td_str = pd.Series(['1 days', '2 days', '3 days'])
td = pd.to_timedelta(td_str)
print("字符串转timedelta：")
print(td)

# 数值转timedelta
td_num = pd.to_timedelta([1, 2, 3], unit='D')
print("\n数值转timedelta（天）：")
print(td_num)

# 不同单位
td_hours = pd.to_timedelta([1, 2, 3], unit='h')
print("\n数值转timedelta（小时）：")
print(td_hours)
```

## 12.5 可空数据类型

### 12.5.1 新的可空整数类型

```python
# 传统整数类型不支持NaN
s_int = pd.Series([1, 2, np.nan, 4, 5])
print("传统整数处理NaN：")
print(s_int)
print("数据类型：", s_int.dtype)

# 新的可空整数类型
s_int_nullable = pd.Series([1, 2, pd.NA, 4, 5], dtype='Int64')
print("\n可空整数类型：")
print(s_int_nullable)
print("数据类型：", s_int_nullable.dtype)

# 转换为可空类型
s_converted = s_int.astype('Int64')
print("\n转换为可空类型：")
print(s_converted)
```

### 12.5.2 可空数据类型列表

```python
# 可空类型示例
nullable_types = {
    'Int8': pd.array([1, 2, pd.NA], dtype='Int8'),
    'Int16': pd.array([1, 2, pd.NA], dtype='Int16'),
    'Int32': pd.array([1, 2, pd.NA], dtype='Int32'),
    'Int64': pd.array([1, 2, pd.NA], dtype='Int64'),
    'UInt8': pd.array([1, 2, pd.NA], dtype='UInt8'),
    'Float32': pd.array([1.1, 2.2, pd.NA], dtype='Float32'),
    'Float64': pd.array([1.1, 2.2, pd.NA], dtype='Float64'),
    'boolean': pd.array([True, False, pd.NA], dtype='boolean'),
    'string': pd.array(['a', 'b', pd.NA], dtype='string')
}

df_nullable = pd.DataFrame(nullable_types)
print("可空数据类型：")
print(df_nullable)
print("\n数据类型：")
print(df_nullable.dtypes)
```

### 12.5.3 StringDtype

```python
# 传统字符串（object类型）
s_object = pd.Series(['a', 'b', 'c', None])
print("object类型字符串：")
print(s_object)
print("数据类型：", s_object.dtype)

# 新的string类型
s_string = pd.Series(['a', 'b', 'c', pd.NA], dtype='string')
print("\nstring类型：")
print(s_string)
print("数据类型：", s_string.dtype)

# 字符串方法
s_string_methods = pd.Series(['hello', 'WORLD', 'Pandas'], dtype='string')
print("\n字符串操作：")
print("原始：", s_string_methods.values)
print("大写：", s_string_methods.str.upper().values)
print("小写：", s_string_methods.str.lower().values)
```

## 12.6 自定义数据类型

### 12.6.1 扩展数据类型

```python
# Pandas的扩展数据类型系统允许创建自定义类型
# 这是高级主题，这里给出概念示例

from pandas.api.extensions import ExtensionDtype

# 查看所有注册的扩展类型
print("扩展数据类型示例：")
print("- Categorical")
print("- Int64 (可空整数)")
print("- string (字符串)")
print("- boolean (可空布尔)")
```

## 12.7 类型推断

```python
# 自动类型推断
data_mixed = {
    'A': [1, 2, 3],
    'B': [1.1, 2.2, 3.3],
    'C': ['a', 'b', 'c'],
    'D': [True, False, True],
    'E': pd.date_range('2024-01-01', periods=3)
}

df_infer = pd.DataFrame(data_mixed)
print("自动类型推断：")
print(df_infer.dtypes)

# infer_objects方法
df_mixed = pd.DataFrame({'A': [1, 2, 3]}, dtype=object)
print("\n原始类型（object）：")
print(df_mixed.dtypes)

df_inferred = df_mixed.infer_objects()
print("推断后类型：")
print(df_inferred.dtypes)

# convert_dtypes方法（转换为最佳类型）
df_best = df_mixed.convert_dtypes()
print("\n转换为最佳类型：")
print(df_best.dtypes)
```

## 12.8 类型检查

```python
# 检查数据类型
df = pd.DataFrame({
    'int_col': [1, 2, 3],
    'float_col': [1.1, 2.2, 3.3],
    'str_col': ['a', 'b', 'c'],
    'bool_col': [True, False, True],
    'date_col': pd.date_range('2024-01-01', periods=3),
    'cat_col': pd.Categorical(['A', 'B', 'C'])
})

# 使用select_dtypes
print("选择数值列：")
print(df.select_dtypes(include=['number']).columns.tolist())

print("\n选择对象列：")
print(df.select_dtypes(include=['object', 'category']).columns.tolist())

print("\n选择日期时间列：")
print(df.select_dtypes(include=['datetime']).columns.tolist())

# 排除特定类型
print("\n排除数值列：")
print(df.select_dtypes(exclude=['number']).columns.tolist())

# 检查具体类型
print("\nint列是否为整数类型：")
print(pd.api.types.is_integer_dtype(df['int_col']))

print("float列是否为浮点类型：")
print(pd.api.types.is_float_dtype(df['float_col']))

print("str列是否为对象类型：")
print(pd.api.types.is_object_dtype(df['str_col']))

print("date列是否为日期类型：")
print(pd.api.types.is_datetime64_any_dtype(df['date_col']))
```

## 12.9 综合案例：数据类型优化

```python
# 创建一个大型DataFrame
n = 1000000
df_large = pd.DataFrame({
    'id': range(n),
    'category': np.random.choice(['A', 'B', 'C', 'D', 'E'], n),
    'value': np.random.randn(n),
    'flag': np.random.choice([True, False], n),
    'date': pd.date_range('2024-01-01', periods=n, freq='s')
})

print("原始DataFrame：")
print(f"形状: {df_large.shape}")
print(f"内存使用: {df_large.memory_usage(deep=True).sum() / 1024**2:.2f} MB")
print("\n数据类型：")
print(df_large.dtypes)

# 优化数据类型
df_optimized = df_large.copy()

# 1. 整数向下转型
df_optimized['id'] = df_optimized['id'].astype('int32')

# 2. 使用类别类型
df_optimized['category'] = df_optimized['category'].astype('category')

# 3. 浮点数向下转型
df_optimized['value'] = df_optimized['value'].astype('float32')

# 4. 布尔类型已经很优化了，但可以使用可空布尔
# df_optimized['flag'] = df_optimized['flag'].astype('boolean')

print("\n优化后DataFrame：")
print(f"形状: {df_optimized.shape}")
print(f"内存使用: {df_optimized.memory_usage(deep=True).sum() / 1024**2:.2f} MB")
print("\n数据类型：")
print(df_optimized.dtypes)

# 计算节省的内存
original_memory = df_large.memory_usage(deep=True).sum()
optimized_memory = df_optimized.memory_usage(deep=True).sum()
saved_memory = original_memory - optimized_memory
saved_pct = (saved_memory / original_memory) * 100

print(f"\n内存节省: {saved_memory / 1024**2:.2f} MB ({saved_pct:.1f}%)")
```

## 12.10 练习题

1. **基础练习**：创建包含多种数据类型的DataFrame，并进行类型转换。

2. **类别数据**：将字符串列转换为类别类型，比较内存使用。

3. **日期时间**：解析不同格式的日期字符串，提取日期组件。

4. **类型优化**：优化一个大型DataFrame的数据类型，减少内存使用。

5. **综合案例**：处理混合类型的数据，进行清洗和类型转换。

## 12.11 小结

本章介绍了Pandas中的数据类型和转换：

- **基本类型**：整数、浮点、字符串、布尔、日期时间
- **类别类型**：节省内存，提高性能
- **日期时间类型**：datetime64、timedelta64、Period
- **类型转换**：astype、to_numeric、to_datetime、to_timedelta
- **可空类型**：Int64、Float64、boolean、string
- **类型检查**：select_dtypes、is_*_dtype函数
- **类型优化**：减少内存使用，提高性能

正确使用数据类型可以：
- 节省内存
- 提高性能
- 避免错误
- 提高代码可读性

## 下一章

在下一章中，我们将深入学习**缺失值处理**的高级技巧。
