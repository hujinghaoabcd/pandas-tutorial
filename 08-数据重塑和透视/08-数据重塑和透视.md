# 第8章：数据重塑和透视

数据重塑是将数据从一种格式转换为另一种格式的过程。Pandas提供了多种强大的工具来重塑数据，包括pivot、stack、unstack、melt等。本章将详细介绍这些技术和实践应用。

## 8.1 宽格式和长格式

### 8.1.1 理解数据格式

```python
import pandas as pd
import numpy as np

# 宽格式数据（Wide Format）
wide_data = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Math': [90, 85, 88],
    'English': [88, 92, 85],
    'Science': [92, 87, 90]
})

print("宽格式数据：")
print(wide_data)

# 长格式数据（Long Format）
long_data = pd.DataFrame({
    'Name': ['Alice', 'Alice', 'Alice', 'Bob', 'Bob', 'Bob',
             'Charlie', 'Charlie', 'Charlie'],
    'Subject': ['Math', 'English', 'Science', 'Math', 'English', 'Science',
                'Math', 'English', 'Science'],
    'Score': [90, 88, 92, 85, 92, 87, 88, 85, 90]
})

print("\n长格式数据：")
print(long_data)
```

## 8.2 melt()：宽格式转长格式

### 8.2.1 基本用法

```python
# 创建宽格式数据
wide = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Math': [90, 85, 88],
    'English': [88, 92, 85],
    'Science': [92, 87, 90]
})

print("原始宽格式数据：")
print(wide)

# 转换为长格式
long = pd.melt(wide, id_vars=['Name'],
               var_name='Subject', value_name='Score')
print("\n转换为长格式：")
print(long)
```

### 8.2.2 指定要融合的列

```python
# 创建更复杂的数据
data = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [20, 21, 22],
    'Math': [90, 85, 88],
    'English': [88, 92, 85],
    'Science': [92, 87, 90]
})

print("原始数据：")
print(data)

# 只融合成绩列
long = pd.melt(data, id_vars=['Name', 'Age'],
               value_vars=['Math', 'English', 'Science'],
               var_name='Subject', value_name='Score')
print("\n融合成绩列：")
print(long)
```

### 8.2.3 处理多列标识符

```python
# 创建包含多个标识列的数据
data = pd.DataFrame({
    'Class': ['A', 'A', 'B', 'B'],
    'Name': ['Alice', 'Bob', 'Charlie', 'David'],
    'Midterm': [85, 90, 88, 92],
    'Final': [88, 92, 90, 95]
})

print("原始数据：")
print(data)

# 融合考试成绩
long = pd.melt(data, id_vars=['Class', 'Name'],
               var_name='Exam', value_name='Score')
print("\n融合后的数据：")
print(long)
```

## 8.3 pivot()：长格式转宽格式

### 8.3.1 基本用法

```python
# 创建长格式数据
long = pd.DataFrame({
    'Name': ['Alice', 'Alice', 'Alice', 'Bob', 'Bob', 'Bob'],
    'Subject': ['Math', 'English', 'Science', 'Math', 'English', 'Science'],
    'Score': [90, 88, 92, 85, 92, 87]
})

print("原始长格式数据：")
print(long)

# 转换为宽格式
wide = long.pivot(index='Name', columns='Subject', values='Score')
print("\n转换为宽格式：")
print(wide)

# 重置索引使Name成为普通列
wide_reset = wide.reset_index()
print("\n重置索引后：")
print(wide_reset)
```

### 8.3.2 多索引pivot

```python
# 创建包含多个维度的数据
data = pd.DataFrame({
    'Class': ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'],
    'Name': ['Alice', 'Alice', 'Bob', 'Bob',
             'Charlie', 'Charlie', 'David', 'David'],
    'Subject': ['Math', 'English', 'Math', 'English',
                'Math', 'English', 'Math', 'English'],
    'Score': [90, 88, 85, 92, 88, 85, 92, 95]
})

print("原始数据：")
print(data)

# 使用多个索引
wide = data.pivot(index=['Class', 'Name'],
                  columns='Subject', values='Score')
print("\n多索引pivot：")
print(wide)
```

### 8.3.3 处理重复值

```python
# 创建包含重复值的数据
data = pd.DataFrame({
    'Name': ['Alice', 'Alice', 'Bob', 'Bob'],
    'Subject': ['Math', 'Math', 'Math', 'Math'],
    'Score': [90, 92, 85, 87]
})

print("包含重复值的数据：")
print(data)

# pivot会报错，因为有重复的索引组合
# wide = data.pivot(index='Name', columns='Subject', values='Score')  # 会报错

# 解决方案1：使用pivot_table并指定聚合函数
wide = data.pivot_table(index='Name', columns='Subject',
                        values='Score', aggfunc='mean')
print("\n使用pivot_table处理重复值（取平均）：")
print(wide)
```

## 8.4 pivot_table()：带聚合的透视

### 8.4.1 基本用法

```python
# 创建销售数据
sales = pd.DataFrame({
    'Date': ['2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02',
             '2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02'],
    'Region': ['North', 'North', 'North', 'North',
               'South', 'South', 'South', 'South'],
    'Product': ['A', 'B', 'A', 'B', 'A', 'B', 'A', 'B'],
    'Sales': [100, 150, 120, 130, 90, 110, 100, 120]
})

print("原始销售数据：")
print(sales)

# 创建数据透视表
pivot = pd.pivot_table(sales, values='Sales',
                       index='Region', columns='Product',
                       aggfunc='sum')
print("\n数据透视表：")
print(pivot)
```

### 8.4.2 多个聚合函数

```python
# 使用多个聚合函数
pivot = pd.pivot_table(sales, values='Sales',
                       index='Region', columns='Product',
                       aggfunc=['sum', 'mean', 'count'])
print("多个聚合函数：")
print(pivot)
```

### 8.4.3 多个值列

```python
# 创建包含多个值的数据
sales_multi = pd.DataFrame({
    'Region': ['North', 'North', 'South', 'South'],
    'Product': ['A', 'B', 'A', 'B'],
    'Sales': [100, 150, 90, 110],
    'Quantity': [10, 15, 9, 11]
})

print("包含多个值的数据：")
print(sales_multi)

# 透视多个值列
pivot = pd.pivot_table(sales_multi,
                       values=['Sales', 'Quantity'],
                       index='Region', columns='Product',
                       aggfunc='sum')
print("\n透视多个值列：")
print(pivot)
```

### 8.4.4 添加总计

```python
# 添加行和列的总计
pivot = pd.pivot_table(sales, values='Sales',
                       index='Region', columns='Product',
                       aggfunc='sum', margins=True,
                       margins_name='Total')
print("添加总计：")
print(pivot)
```

### 8.4.5 填充缺失值

```python
# 创建有缺失值的数据
data = pd.DataFrame({
    'A': ['X', 'X', 'Y', 'Y'],
    'B': ['M', 'N', 'M', 'O'],
    'C': [1, 2, 3, 4]
})

print("原始数据：")
print(data)

# 透视后会产生缺失值
pivot = pd.pivot_table(data, values='C', index='A', columns='B',
                       aggfunc='sum')
print("\n透视后（有缺失值）：")
print(pivot)

# 填充缺失值
pivot_filled = pd.pivot_table(data, values='C', index='A', columns='B',
                              aggfunc='sum', fill_value=0)
print("\n填充缺失值后：")
print(pivot_filled)
```

## 8.5 stack()和unstack()：层次化索引操作

### 8.5.1 stack()：列转行

```python
# 创建宽格式数据
data = pd.DataFrame({
    'Math': [90, 85, 88],
    'English': [88, 92, 85],
    'Science': [92, 87, 90]
}, index=['Alice', 'Bob', 'Charlie'])

print("原始数据：")
print(data)

# stack：将列索引变为行索引
stacked = data.stack()
print("\nstack后（Series）：")
print(stacked)
print(f"类型: {type(stacked)}")

# 转换为DataFrame
stacked_df = stacked.to_frame(name='Score')
print("\n转换为DataFrame：")
print(stacked_df)
```

### 8.5.2 unstack()：行转列

```python
# 创建多层索引的Series
index = pd.MultiIndex.from_tuples([
    ('Alice', 'Math'), ('Alice', 'English'), ('Alice', 'Science'),
    ('Bob', 'Math'), ('Bob', 'English'), ('Bob', 'Science')
], names=['Name', 'Subject'])

series = pd.Series([90, 88, 92, 85, 92, 87], index=index)
print("多层索引Series：")
print(series)

# unstack：将行索引变为列索引
unstacked = series.unstack()
print("\nunstack后：")
print(unstacked)

# 指定level
unstacked_level = series.unstack(level=0)
print("\nunstack level=0：")
print(unstacked_level)

unstacked_level = series.unstack(level='Subject')
print("\nunstack level='Subject'：")
print(unstacked_level)
```

### 8.5.3 多层操作

```python
# 创建多层索引DataFrame
arrays = [
    ['A', 'A', 'B', 'B'],
    ['X', 'Y', 'X', 'Y']
]
index = pd.MultiIndex.from_arrays(arrays, names=['Group', 'SubGroup'])
data = pd.DataFrame({
    'Value1': [1, 2, 3, 4],
    'Value2': [5, 6, 7, 8]
}, index=index)

print("多层索引DataFrame：")
print(data)

# stack列
stacked = data.stack()
print("\nstack后：")
print(stacked)

# unstack到不同层级
unstacked_0 = stacked.unstack(level=0)
print("\nunstack level=0：")
print(unstacked_0)

unstacked_1 = stacked.unstack(level=1)
print("\nunstack level=1：")
print(unstacked_1)

unstacked_2 = stacked.unstack(level=2)
print("\nunstack level=2：")
print(unstacked_2)
```

### 8.5.4 处理缺失值

```python
# 创建有缺失值的数据
data = pd.DataFrame({
    'A': [1, 2, np.nan],
    'B': [4, np.nan, 6],
    'C': [7, 8, 9]
}, index=['X', 'Y', 'Z'])

print("原始数据：")
print(data)

# stack默认会删除NaN
stacked = data.stack()
print("\nstack后（默认删除NaN）：")
print(stacked)

# 保留NaN
stacked_dropna = data.stack(dropna=False)
print("\nstack后（保留NaN）：")
print(stacked_dropna)
```

## 8.6 crosstab()：交叉表

### 8.6.1 基本用法

```python
# 创建分类数据
data = pd.DataFrame({
    'Gender': ['M', 'F', 'M', 'F', 'M', 'F', 'M', 'F'],
    'Handedness': ['Right', 'Right', 'Left', 'Right',
                   'Right', 'Left', 'Left', 'Right'],
    'Age': [25, 30, 22, 28, 35, 27, 29, 31]
})

print("原始数据：")
print(data)

# 创建交叉表
cross = pd.crosstab(data['Gender'], data['Handedness'])
print("\n交叉表：")
print(cross)
```

### 8.6.2 多维交叉表

```python
# 创建包含多个分类变量的数据
data = pd.DataFrame({
    'Gender': ['M', 'F', 'M', 'F'] * 2,
    'Handedness': ['Right', 'Right', 'Left', 'Right',
                   'Right', 'Left', 'Left', 'Right'],
    'AgeGroup': ['Young', 'Old', 'Young', 'Old',
                 'Young', 'Old', 'Young', 'Old']
})

print("原始数据：")
print(data)

# 多行交叉表
cross = pd.crosstab([data['Gender'], data['AgeGroup']],
                    data['Handedness'])
print("\n多行交叉表：")
print(cross)

# 多列交叉表
cross = pd.crosstab(data['Gender'],
                    [data['Handedness'], data['AgeGroup']])
print("\n多列交叉表：")
print(cross)
```

### 8.6.3 添加值和聚合

```python
# 创建包含数值的数据
data = pd.DataFrame({
    'Gender': ['M', 'F', 'M', 'F', 'M', 'F'],
    'Product': ['A', 'A', 'B', 'B', 'A', 'B'],
    'Sales': [100, 150, 120, 130, 110, 140]
})

print("原始数据：")
print(data)

# 交叉表显示销售额总和
cross = pd.crosstab(data['Gender'], data['Product'],
                    values=data['Sales'], aggfunc='sum')
print("\n销售额总和：")
print(cross)

# 多个聚合函数
cross = pd.crosstab(data['Gender'], data['Product'],
                    values=data['Sales'],
                    aggfunc=['sum', 'mean', 'count'])
print("\n多个聚合函数：")
print(cross)
```

### 8.6.4 标准化

```python
# 创建数据
data = pd.DataFrame({
    'Gender': ['M', 'F', 'M', 'F', 'M', 'F', 'M', 'F'],
    'Preference': ['A', 'A', 'B', 'B', 'A', 'B', 'B', 'A']
})

# 频数统计
cross = pd.crosstab(data['Gender'], data['Preference'])
print("频数统计：")
print(cross)

# 行标准化（每行的和为1）
cross_row = pd.crosstab(data['Gender'], data['Preference'],
                        normalize='index')
print("\n行标准化：")
print(cross_row)

# 列标准化（每列的和为1）
cross_col = pd.crosstab(data['Gender'], data['Preference'],
                        normalize='columns')
print("\n列标准化：")
print(cross_col)

# 全局标准化（所有值的和为1）
cross_all = pd.crosstab(data['Gender'], data['Preference'],
                        normalize='all')
print("\n全局标准化：")
print(cross_all)
```

## 8.7 wide_to_long()：特殊的重塑

```python
# 创建宽格式数据（常见于重复测量数据）
data = pd.DataFrame({
    'id': [1, 2, 3],
    'name': ['Alice', 'Bob', 'Charlie'],
    'score_time1': [85, 90, 88],
    'score_time2': [88, 92, 90],
    'score_time3': [90, 93, 92]
})

print("原始宽格式数据：")
print(data)

# 转换为长格式
long = pd.wide_to_long(data, stubnames='score', i=['id', 'name'],
                       j='time', sep='_time')
print("\n转换为长格式：")
print(long.reset_index())
```

## 8.8 综合案例：重塑真实数据

```python
# 创建模拟的学生成绩数据（宽格式）
wide_grades = pd.DataFrame({
    'StudentID': [1, 2, 3, 4, 5],
    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
    'Class': ['A', 'A', 'B', 'B', 'A'],
    'Math_Midterm': [85, 90, 88, 92, 87],
    'Math_Final': [88, 92, 90, 95, 89],
    'English_Midterm': [90, 85, 92, 88, 91],
    'English_Final': [92, 87, 93, 90, 93],
    'Science_Midterm': [87, 92, 85, 90, 88],
    'Science_Final': [89, 93, 87, 92, 90]
})

print("原始宽格式数据：")
print(wide_grades)

# 步骤1：使用melt将科目和考试类型展开
long = pd.melt(wide_grades,
               id_vars=['StudentID', 'Name', 'Class'],
               var_name='Subject_Exam', value_name='Score')
print("\n步骤1 - 初步melt：")
print(long.head(10))

# 步骤2：分离科目和考试类型
long[['Subject', 'Exam']] = long['Subject_Exam'].str.split('_', expand=True)
long = long.drop('Subject_Exam', axis=1)
print("\n步骤2 - 分离科目和考试类型：")
print(long.head(10))

# 步骤3：创建透视表 - 学生在各科目的平均分
avg_by_subject = pd.pivot_table(long, values='Score',
                                 index=['StudentID', 'Name', 'Class'],
                                 columns='Subject', aggfunc='mean')
print("\n步骤3 - 各科目平均分：")
print(avg_by_subject)

# 步骤4：创建透视表 - 各班级各科目的表现
class_performance = pd.pivot_table(long, values='Score',
                                    index='Subject',
                                    columns=['Class', 'Exam'],
                                    aggfunc='mean')
print("\n步骤4 - 各班级各科目表现：")
print(class_performance)

# 步骤5：创建交叉表 - 统计各分数段的学生数
long['Grade'] = pd.cut(long['Score'],
                       bins=[0, 60, 70, 80, 90, 100],
                       labels=['F', 'D', 'C', 'B', 'A'])
grade_dist = pd.crosstab([long['Subject'], long['Exam']],
                         long['Grade'])
print("\n步骤5 - 分数段分布：")
print(grade_dist)

# 步骤6：使用pivot重新转换为宽格式（每个学生一行）
wide_avg = long.pivot_table(values='Score',
                            index=['StudentID', 'Name', 'Class'],
                            columns=['Subject', 'Exam'])
print("\n步骤6 - 转换回宽格式：")
print(wide_avg)

# 步骤7：计算每个学生的总平均分
wide_avg['Overall_Average'] = wide_avg.mean(axis=1)
print("\n步骤7 - 添加总平均分：")
print(wide_avg)
```

## 8.9 性能考虑

### 8.9.1 选择合适的方法

```python
import time

# 创建测试数据
n = 10000
data = pd.DataFrame({
    'A': np.random.choice(['X', 'Y', 'Z'], n),
    'B': np.random.choice(['M', 'N'], n),
    'C': np.random.randn(n)
})

# 方法1：pivot_table
start = time.time()
result1 = data.pivot_table(values='C', index='A', columns='B', aggfunc='mean')
time1 = time.time() - start

# 方法2：groupby + unstack
start = time.time()
result2 = data.groupby(['A', 'B'])['C'].mean().unstack()
time2 = time.time() - start

print(f"pivot_table耗时: {time1:.4f}秒")
print(f"groupby + unstack耗时: {time2:.4f}秒")
print(f"结果是否相同: {result1.equals(result2)}")
```

## 8.10 练习题

1. **基础练习**：创建一个学生成绩的宽格式数据，转换为长格式，再转换回去。

2. **数据透视**：创建一个销售数据集，使用pivot_table从多个维度分析数据。

3. **stack/unstack**：创建一个多层索引的数据，练习不同层级的stack和unstack操作。

4. **交叉表**：创建一个分类数据集，使用crosstab进行频数统计和比例分析。

5. **综合案例**：重塑一个包含时间序列和多个维度的复杂数据集。

## 8.11 小结

本章介绍了Pandas中的数据重塑和透视技术：

- **melt()**：宽格式转长格式
- **pivot()**：长格式转宽格式（无聚合）
- **pivot_table()**：长格式转宽格式（带聚合）
- **stack()/unstack()**：层次化索引的行列转换
- **crosstab()**：交叉表和频数统计
- **wide_to_long()**：特殊的宽转长操作

选择合适的方法取决于：
- 数据的当前格式
- 目标格式
- 是否需要聚合
- 是否有重复值

## 下一章

在下一章中，我们将学习**时间序列**，包括日期时间处理、时间序列索引、重采样等。
