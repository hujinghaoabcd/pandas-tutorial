# 第6章：数据合并和连接

在实际数据分析中，我们经常需要将多个数据源合并在一起。Pandas提供了多种强大的工具来合并、连接和组合数据集。本章将详细介绍这些技术。

## 6.1 concat()：数据拼接

`concat()`函数用于沿着一条轴将多个对象堆叠在一起。

### 6.1.1 垂直拼接（行拼接）

```python
import pandas as pd
import numpy as np

# 创建三个DataFrame
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df2 = pd.DataFrame({
    'A': ['A3', 'A4', 'A5'],
    'B': ['B3', 'B4', 'B5']
})

df3 = pd.DataFrame({
    'A': ['A6', 'A7', 'A8'],
    'B': ['B6', 'B7', 'B8']
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)
print("\nDataFrame 3:")
print(df3)

# 垂直拼接（默认axis=0）
result = pd.concat([df1, df2, df3])
print("\n垂直拼接结果：")
print(result)

# 重置索引
result_reset = pd.concat([df1, df2, df3], ignore_index=True)
print("\n重置索引后：")
print(result_reset)
```

### 6.1.2 水平拼接（列拼接）

```python
# 创建两个DataFrame
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df2 = pd.DataFrame({
    'C': ['C0', 'C1', 'C2'],
    'D': ['D0', 'D1', 'D2']
})

# 水平拼接
result = pd.concat([df1, df2], axis=1)
print("水平拼接结果：")
print(result)
```

### 6.1.3 处理不同的列

```python
# 创建列不完全相同的DataFrame
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df2 = pd.DataFrame({
    'B': ['B3', 'B4', 'B5'],
    'C': ['C3', 'C4', 'C5']
})

# 外连接（默认）- 保留所有列
result_outer = pd.concat([df1, df2])
print("外连接（保留所有列）：")
print(result_outer)

# 内连接 - 只保留共同列
result_inner = pd.concat([df1, df2], join='inner')
print("\n内连接（只保留共同列）：")
print(result_inner)
```

### 6.1.4 使用keys创建层次化索引

```python
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df2 = pd.DataFrame({
    'A': ['A3', 'A4', 'A5'],
    'B': ['B3', 'B4', 'B5']
})

# 使用keys参数
result = pd.concat([df1, df2], keys=['dataset1', 'dataset2'])
print("带层次化索引的拼接：")
print(result)

# 访问特定数据集
print("\n访问dataset1：")
print(result.loc['dataset1'])
```

## 6.2 merge()：数据库风格的合并

`merge()`函数实现了类似SQL的JOIN操作。

### 6.2.1 基于共同列的合并

```python
# 创建两个DataFrame
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C', 'D'],
    'value1': [1, 2, 3, 4]
})

df2 = pd.DataFrame({
    'key': ['B', 'D', 'E', 'F'],
    'value2': [5, 6, 7, 8]
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 内连接（默认）
inner_join = pd.merge(df1, df2, on='key')
print("\n内连接（inner join）：")
print(inner_join)

# 左连接
left_join = pd.merge(df1, df2, on='key', how='left')
print("\n左连接（left join）：")
print(left_join)

# 右连接
right_join = pd.merge(df1, df2, on='key', how='right')
print("\n右连接（right join）：")
print(right_join)

# 外连接
outer_join = pd.merge(df1, df2, on='key', how='outer')
print("\n外连接（outer join）：")
print(outer_join)
```

### 6.2.2 基于多个列的合并

```python
# 创建两个DataFrame
df1 = pd.DataFrame({
    'key1': ['A', 'A', 'B', 'B'],
    'key2': ['X', 'Y', 'X', 'Y'],
    'value1': [1, 2, 3, 4]
})

df2 = pd.DataFrame({
    'key1': ['A', 'B', 'B', 'C'],
    'key2': ['X', 'X', 'Y', 'X'],
    'value2': [5, 6, 7, 8]
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 基于多个列合并
result = pd.merge(df1, df2, on=['key1', 'key2'])
print("\n基于多个列合并：")
print(result)
```

### 6.2.3 列名不同的合并

```python
# 创建列名不同的DataFrame
df1 = pd.DataFrame({
    'left_key': ['A', 'B', 'C', 'D'],
    'value1': [1, 2, 3, 4]
})

df2 = pd.DataFrame({
    'right_key': ['B', 'D', 'E', 'F'],
    'value2': [5, 6, 7, 8]
})

# 使用left_on和right_on
result = pd.merge(df1, df2, left_on='left_key', right_on='right_key')
print("列名不同的合并：")
print(result)

# 删除重复的键列
result_clean = pd.merge(df1, df2, left_on='left_key', right_on='right_key').drop('right_key', axis=1)
print("\n删除重复键列后：")
print(result_clean)
```

### 6.2.4 基于索引的合并

```python
# 创建两个DataFrame，使用索引作为键
df1 = pd.DataFrame({
    'value1': [1, 2, 3, 4]
}, index=['A', 'B', 'C', 'D'])

df2 = pd.DataFrame({
    'value2': [5, 6, 7, 8]
}, index=['B', 'D', 'E', 'F'])

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 基于索引合并
result = pd.merge(df1, df2, left_index=True, right_index=True, how='outer')
print("\n基于索引合并：")
print(result)
```

### 6.2.5 处理重复列名

```python
# 创建有重复列名的DataFrame
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['A', 'B', 'D'],
    'value': [4, 5, 6]
})

# 使用suffixes参数
result = pd.merge(df1, df2, on='key', suffixes=('_left', '_right'))
print("处理重复列名：")
print(result)
```

### 6.2.6 指示器（indicator）

```python
# 创建两个DataFrame
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value1': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['B', 'C', 'D'],
    'value2': [4, 5, 6]
})

# 使用indicator参数
result = pd.merge(df1, df2, on='key', how='outer', indicator=True)
print("使用指示器：")
print(result)

# 自定义指示器列名
result_custom = pd.merge(df1, df2, on='key', how='outer', indicator='source')
print("\n自定义指示器列名：")
print(result_custom)
```

## 6.3 join()：基于索引的连接

`join()`方法是基于索引进行连接的简便方法。

### 6.3.1 基本join操作

```python
# 创建两个DataFrame
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
}, index=['K0', 'K1', 'K2'])

df2 = pd.DataFrame({
    'C': ['C0', 'C1', 'C2'],
    'D': ['D0', 'D1', 'D2']
}, index=['K0', 'K2', 'K3'])

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 左连接（默认）
result = df1.join(df2)
print("\n左连接：")
print(result)

# 内连接
result_inner = df1.join(df2, how='inner')
print("\n内连接：")
print(result_inner)

# 外连接
result_outer = df1.join(df2, how='outer')
print("\n外连接：")
print(result_outer)
```

### 6.3.2 join多个DataFrame

```python
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2']
}, index=['K0', 'K1', 'K2'])

df2 = pd.DataFrame({
    'B': ['B0', 'B1', 'B2']
}, index=['K0', 'K1', 'K2'])

df3 = pd.DataFrame({
    'C': ['C0', 'C1', 'C2']
}, index=['K0', 'K1', 'K2'])

# join多个DataFrame
result = df1.join([df2, df3])
print("join多个DataFrame：")
print(result)
```

### 6.3.3 join时使用列而非索引

```python
# 创建DataFrame
df1 = pd.DataFrame({
    'key': ['K0', 'K1', 'K2'],
    'A': ['A0', 'A1', 'A2']
})

df2 = pd.DataFrame({
    'B': ['B0', 'B1', 'B2']
}, index=['K0', 'K1', 'K2'])

# 使用on参数指定列
result = df1.join(df2, on='key')
print("使用列进行join：")
print(result)
```

## 6.4 combine_first()：填充缺失值

`combine_first()`方法用一个对象中的值填充另一个对象中的缺失值。

```python
# 创建两个有缺失值的DataFrame
df1 = pd.DataFrame({
    'A': [1, np.nan, 3, np.nan],
    'B': [4, 5, np.nan, 7]
})

df2 = pd.DataFrame({
    'A': [np.nan, 2, np.nan, 4],
    'B': [np.nan, np.nan, 6, 8],
    'C': [9, 10, 11, 12]
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 用df2填充df1的缺失值
result = df1.combine_first(df2)
print("\n使用combine_first填充：")
print(result)
```

## 6.5 append()：追加行（已弃用）

注意：`append()`方法在Pandas 2.0中已被弃用，推荐使用`concat()`。

```python
# 创建DataFrame
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df2 = pd.DataFrame({
    'A': ['A3', 'A4'],
    'B': ['B3', 'B4']
})

# 推荐使用concat代替append
result = pd.concat([df1, df2], ignore_index=True)
print("使用concat追加行：")
print(result)

# 追加单行（使用字典）
new_row = {'A': 'A5', 'B': 'B5'}
result = pd.concat([result, pd.DataFrame([new_row])], ignore_index=True)
print("\n追加单行：")
print(result)
```

## 6.6 综合案例：合并多个数据源

```python
# 模拟真实场景：合并订单、客户和产品信息

# 订单数据
orders = pd.DataFrame({
    'order_id': [1, 2, 3, 4, 5],
    'customer_id': [101, 102, 103, 101, 104],
    'product_id': [201, 202, 201, 203, 202],
    'quantity': [2, 1, 3, 1, 2],
    'order_date': pd.date_range('2024-01-01', periods=5)
})

# 客户数据
customers = pd.DataFrame({
    'customer_id': [101, 102, 103, 104, 105],
    'customer_name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
    'city': ['Beijing', 'Shanghai', 'Guangzhou', 'Shenzhen', 'Hangzhou'],
    'vip': [True, False, True, False, True]
})

# 产品数据
products = pd.DataFrame({
    'product_id': [201, 202, 203, 204],
    'product_name': ['Laptop', 'Mouse', 'Keyboard', 'Monitor'],
    'price': [5000, 50, 200, 1500],
    'category': ['Electronics', 'Accessories', 'Accessories', 'Electronics']
})

print("订单数据：")
print(orders)
print("\n客户数据：")
print(customers)
print("\n产品数据：")
print(products)

# 第一步：合并订单和客户信息
orders_customers = pd.merge(orders, customers, on='customer_id', how='left')
print("\n合并订单和客户信息：")
print(orders_customers)

# 第二步：合并产品信息
complete_data = pd.merge(orders_customers, products, on='product_id', how='left')
print("\n完整的订单信息：")
print(complete_data)

# 第三步：计算总价
complete_data['total_price'] = complete_data['quantity'] * complete_data['price']
print("\n添加总价列：")
print(complete_data)

# 第四步：数据分析
print("\n按客户统计：")
customer_stats = complete_data.groupby('customer_name').agg({
    'order_id': 'count',
    'quantity': 'sum',
    'total_price': 'sum'
}).rename(columns={
    'order_id': 'order_count',
    'quantity': 'total_quantity',
    'total_price': 'total_spent'
})
print(customer_stats)

print("\n按产品统计：")
product_stats = complete_data.groupby('product_name').agg({
    'order_id': 'count',
    'quantity': 'sum',
    'total_price': 'sum'
}).rename(columns={
    'order_id': 'order_count',
    'quantity': 'total_sold',
    'total_price': 'revenue'
})
print(product_stats)

print("\n按城市统计：")
city_stats = complete_data.groupby('city').agg({
    'order_id': 'count',
    'total_price': 'sum'
}).rename(columns={
    'order_id': 'order_count',
    'total_price': 'total_revenue'
})
print(city_stats)
```

## 6.7 高级合并技巧

### 6.7.1 多对多合并

```python
# 创建多对多关系的数据
df1 = pd.DataFrame({
    'key': ['A', 'A', 'B', 'B'],
    'value1': [1, 2, 3, 4]
})

df2 = pd.DataFrame({
    'key': ['A', 'A', 'B', 'C'],
    'value2': [5, 6, 7, 8]
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2:")
print(df2)

# 多对多合并会产生笛卡尔积
result = pd.merge(df1, df2, on='key')
print("\n多对多合并结果：")
print(result)
```

### 6.7.2 使用validate参数验证合并类型

```python
# 创建一对一关系的数据
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value1': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value2': [4, 5, 6]
})

# 验证一对一合并
result = pd.merge(df1, df2, on='key', validate='one_to_one')
print("一对一合并验证：")
print(result)

# 如果数据不符合验证条件会抛出异常
# validate可选值：'one_to_one', 'one_to_many', 'many_to_one', 'many_to_many'
```

### 6.7.3 合并时处理重复键

```python
# 创建有重复键的数据
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value1': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['A', 'A', 'B', 'D'],
    'value2': [4, 5, 6, 7]
})

print("DataFrame 1:")
print(df1)
print("\nDataFrame 2 (有重复键):")
print(df2)

# 合并会保留所有匹配
result = pd.merge(df1, df2, on='key', how='left')
print("\n合并结果：")
print(result)
```

### 6.7.4 按最近的键合并（merge_asof）

```python
# 创建时间序列数据
quotes = pd.DataFrame({
    'time': pd.to_datetime(['2024-01-01 09:00', '2024-01-01 09:05',
                           '2024-01-01 09:10', '2024-01-01 09:15']),
    'price': [100, 102, 98, 103]
})

trades = pd.DataFrame({
    'time': pd.to_datetime(['2024-01-01 09:03', '2024-01-01 09:08',
                           '2024-01-01 09:12']),
    'volume': [50, 100, 75]
})

print("报价数据：")
print(quotes)
print("\n交易数据：")
print(trades)

# 按最近的时间合并
result = pd.merge_asof(trades, quotes, on='time')
print("\n按最近时间合并：")
print(result)

# 指定方向（向前或向后）
result_forward = pd.merge_asof(trades, quotes, on='time', direction='forward')
print("\n向前合并：")
print(result_forward)

result_backward = pd.merge_asof(trades, quotes, on='time', direction='backward')
print("\n向后合并：")
print(result_backward)
```

## 6.8 性能优化技巧

### 6.8.1 选择合适的合并方法

```python
import time

# 创建大数据集
n = 100000
df1 = pd.DataFrame({
    'key': np.random.randint(0, 10000, n),
    'value1': np.random.randn(n)
})

df2 = pd.DataFrame({
    'key': np.random.randint(0, 10000, n),
    'value2': np.random.randn(n)
})

# 方法1：merge
start = time.time()
result1 = pd.merge(df1, df2, on='key')
time1 = time.time() - start
print(f"merge耗时: {time1:.4f}秒")

# 方法2：set_index后join
start = time.time()
df1_indexed = df1.set_index('key')
df2_indexed = df2.set_index('key')
result2 = df1_indexed.join(df2_indexed, how='inner')
time2 = time.time() - start
print(f"set_index + join耗时: {time2:.4f}秒")
```

### 6.8.2 避免不必要的复制

```python
# 创建数据
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value': [4, 5, 6]
})

# 如果只需要部分列，先选择再合并
result = pd.merge(df1[['key', 'value']], df2[['key', 'value']],
                 on='key', suffixes=('_1', '_2'))
print(result)
```

## 6.9 常见问题和解决方案

### 6.9.1 合并后出现意外的NaN

```python
# 问题：列名大小写不一致
df1 = pd.DataFrame({
    'Key': ['A', 'B', 'C'],
    'value1': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value2': [4, 5, 6]
})

# 错误做法：直接合并会失败
# result = pd.merge(df1, df2, on='key')  # 会报错

# 解决方案：统一列名
df1.columns = df1.columns.str.lower()
result = pd.merge(df1, df2, on='key')
print("统一列名后的合并：")
print(result)
```

### 6.9.2 合并后索引混乱

```python
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value1': [1, 2, 3]
}, index=[10, 20, 30])

df2 = pd.DataFrame({
    'key': ['A', 'B', 'D'],
    'value2': [4, 5, 6]
}, index=[100, 200, 300])

# 合并后重置索引
result = pd.merge(df1, df2, on='key').reset_index(drop=True)
print("重置索引后：")
print(result)
```

### 6.9.3 处理数据类型不匹配

```python
# 问题：键的数据类型不一致
df1 = pd.DataFrame({
    'key': [1, 2, 3],
    'value1': ['A', 'B', 'C']
})

df2 = pd.DataFrame({
    'key': ['1', '2', '3'],
    'value2': ['X', 'Y', 'Z']
})

print("df1的key类型:", df1['key'].dtype)
print("df2的key类型:", df2['key'].dtype)

# 转换类型后合并
df2['key'] = df2['key'].astype(int)
result = pd.merge(df1, df2, on='key')
print("\n类型转换后的合并：")
print(result)
```

## 6.10 练习题

1. **基础练习**：创建两个包含学生信息和成绩的DataFrame，使用merge合并它们。

2. **多表合并**：创建订单、客户和产品三个表，合并成完整的订单信息。

3. **时间序列合并**：使用merge_asof合并两个时间序列数据。

4. **数据验证**：使用validate参数验证合并类型，处理不符合预期的数据。

5. **综合案例**：处理包含多个数据源的真实数据集，进行清洗、合并和分析。

## 6.11 小结

本章介绍了Pandas中的数据合并和连接技术：

- **concat()**：用于简单的数据拼接（垂直或水平）
- **merge()**：类似SQL的JOIN操作，功能最强大
- **join()**：基于索引的连接，语法简洁
- **combine_first()**：用于填充缺失值
- **merge_asof()**：按最近的键合并，适合时间序列

选择合适的方法取决于：
- 数据的结构（是否有共同的键）
- 合并的方式（内连接、外连接等）
- 性能要求
- 代码的可读性

## 下一章

在下一章中，我们将学习**数据分组和聚合**，包括groupby操作和各种聚合函数。
