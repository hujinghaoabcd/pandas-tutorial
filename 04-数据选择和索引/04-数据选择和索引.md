# 第04章：数据选择和索引

数据选择和索引是Pandas中最核心、最常用的操作，也是很多初学者觉得困惑的地方。在实际的数据分析工作中，我们经常需要从大量数据中提取特定的行、列或单元格，就像从图书馆的海量藏书中找到你需要的那本书一样。

Pandas提供了多种数据选择方式：`[]`操作符、`loc`、`iloc`、`at`、`iat`等。每种方式都有其特定的使用场景。掌握这些方法，你就能随心所欲地操控数据，像庖丁解牛一般游刃有余。

本章我们将从简单到复杂，系统学习Pandas的数据选择和索引操作。重点讲解loc和iloc的区别，用大量实际例子帮助你深入理解。

---

## 为什么数据选择如此重要？

在数据分析的实际工作中，我们面对的往往是成千上万行的数据。比如：

- **学生成绩管理**：从全校5000名学生中，筛选出某个班级、某门课程不及格的学生
- **销售数据分析**：从全年销售记录中，提取某个地区、某个季度、某类产品的销售数据
- **股票分析**：从历史数据中，找出满足特定条件的交易日
- **电商订单处理**：筛选出特定时间段、特定价格区间的订单

这些场景都需要精准的数据选择能力。可以说，数据选择是数据分析的基础技能，就像武侠小说中的基本功一样重要。

**一个形象的比喻**：如果把DataFrame比作一个Excel表格，那么数据选择就是告诉Pandas："我要第3行到第10行的'成绩'列"，或者"我要所有成绩大于90分的学生信息"。掌握了这些技能，你就能快速定位到需要的数据。

---

## 准备工作

在开始学习之前，我们先准备一些示例数据。这些数据会在整个章节中反复使用。

```python
import pandas as pd
import numpy as np

# 创建学生成绩数据
students_data = {
    '姓名': ['张三', '李四', '王五', '赵六', '钱七', '孙八', '周九', '吴十'],
    '性别': ['男', '女', '男', '女', '男', '女', '男', '女'],
    '年龄': [18, 19, 18, 20, 19, 18, 20, 19],
    '班级': ['一班', '一班', '二班', '二班', '一班', '二班', '一班', '二班'],
    '数学': [85, 92, 78, 88, 95, 73, 90, 82],
    '英语': [90, 88, 85, 92, 87, 78, 93, 95],
    '物理': [78, 85, 92, 80, 88, 85, 82, 90]
}

df = pd.DataFrame(students_data)
print("学生成绩表:")
print(df)
print(f"\n数据形状: {df.shape}")  # (8, 7) - 8行7列
```

输出：
```
学生成绩表:
   姓名 性别  年龄  班级  数学  英语  物理
0  张三  男  18  一班  85  90  78
1  李四  女  19  一班  92  88  85
2  王五  男  18  二班  78  85  92
3  赵六  女  20  二班  88  92  80
4  钱七  男  19  一班  95  87  88
5  孙八  女  18  二班  73  78  85
6  周九  男  20  一班  90  93  82
7  吴十  女  19  二班  82  95  90

数据形状: (8, 7)
```

**理解DataFrame的结构**：
- **行索引**（index）：默认是0, 1, 2, 3...，可以自定义
- **列索引**（columns）：列名，如'姓名'、'性别'等
- **值**（values）：表格中的实际数据

```
行索引    列索引
     ↓  ↓
0    张三  男  18  一班  85  90  78
1    李四  女  19  一班  92  88  85
2    王五  男  18  二班  78  85  92
...
```

---

## []操作符：最基础的选择方式

`[]`操作符是Pandas中最简单、最直观的数据选择方式，类似于字典取值或列表切片。但要注意，它的行为会根据传入的参数类型而变化。

### 选择单列

选择单列是最常见的操作，返回一个Series对象。

```python
# 方式1：用列名（推荐）
math_scores = df['数学']
print("数学成绩:")
print(math_scores)
print(f"类型: {type(math_scores)}")  # <class 'pandas.core.series.Series'>

# 方式2：属性访问（简洁，但列名不能有空格或特殊字符）
# math_scores = df.数学  # 如果列名是纯字母或中文，可以这样用
```

输出：
```
数学成绩:
0    85
1    92
2    78
3    88
4    95
5    73
6    90
7    82
Name: 数学, dtype: int64
类型: <class 'pandas.core.series.Series'>
```

**注意**：
- 返回的是Series，不是DataFrame
- Series保留了原来的行索引
- `Name: 数学` 表示这个Series的名字是'数学'

---

### 选择多列

选择多列需要传入一个列名列表，返回一个DataFrame。

```python
# 选择多列：传入列表
selected_cols = df[['姓名', '数学', '英语']]
print("选择的列:")
print(selected_cols)
print(f"类型: {type(selected_cols)}")  # <class 'pandas.core.frame.DataFrame'>
```

输出：
```
选择的列:
   姓名  数学  英语
0  张三  85  90
1  李四  92  88
2  王五  78  85
3  赵六  88  92
4  钱七  95  87
5  孙八  73  78
6  周九  90  93
7  吴十  82  95
类型: <class 'pandas.core.frame.DataFrame'>
```

**理解双层括号**：
```python
df['数学']           # 单个列名，返回Series
df[['数学']]         # 列名列表，返回DataFrame
df[['数学', '英语']] # 多个列名，返回DataFrame
```

**为什么要用双层括号？**
- 外层 `[]` 是DataFrame的索引操作
- 内层 `[]` 构成一个列表
- 传入列表，Pandas就知道你要选择多列

---

### 选择行（切片）

使用切片可以选择行，语法和Python列表切片一样。

```python
# 选择前3行
first_three = df[0:3]
print("前3行:")
print(first_three)

# 选择第2到第5行（索引1到4）
middle = df[1:5]
print("\n第2到第5行:")
print(middle)

# 选择最后2行
last_two = df[-2:]
print("\n最后2行:")
print(last_two)

# 每隔一行取一个（步长为2）
every_other = df[::2]
print("\n隔行取值:")
print(every_other)
```

输出：
```
前3行:
   姓名 性别  年龄  班级  数学  英语  物理
0  张三  男  18  一班  85  90  78
1  李四  女  19  一班  92  88  85
2  王五  男  18  二班  78  85  92

第2到第5行:
   姓名 性别  年龄  班级  数学  英语  物理
1  李四  女  19  一班  92  88  85
2  王五  男  18  二班  78  85  92
3  赵六  女  20  二班  88  92  80
4  钱七  男  19  一班  95  87  88
...
```

**切片规则**：
- 语法：`df[start:stop:step]`
- 左闭右开：包含start，不包含stop
- 省略start从开头开始，省略stop到末尾结束
- 支持负数索引和步长

**重要提示**：`[]`切片只能用于行，不能直接切列。

```python
# 错误示例
# df[:, 0:2]  # 报错！[]操作符不支持这种语法
```

---

### []操作符的局限性

虽然`[]`操作符简单方便，但存在一些局限：

1. **不够灵活**：不能同时选择指定的行和列
2. **语义不明确**：`df['A']`是选列，`df[0:3]`是选行，容易混淆
3. **功能有限**：不能用标签选择行

```python
# 想要同时选择特定的行和列？[]做不到
# 想要用标签（如'张三'）选择行？[]也做不到

# 这时候就需要loc和iloc了！
```

正因为这些局限，Pandas提供了更强大的选择工具：`loc`和`iloc`。

---

## loc：基于标签的索引（重点！）

`loc`是Pandas中最重要的索引器之一，它基于**标签**（label）进行索引。所谓标签，就是行索引的名称和列名。

### 理解loc的核心概念

**loc的语法**：`df.loc[行标签, 列标签]`

- 行标签：行索引的值（可以是数字，也可以是字符串）
- 列标签：列名
- 支持单个值、列表、切片、布尔数组

**loc vs []**：
- `[]`：语义不明确，功能受限
- `loc`：语义清晰，功能强大，推荐使用

```python
# 先设置一个有意义的行索引
df_with_index = df.set_index('姓名')
print("设置姓名为索引:")
print(df_with_index)
```

输出：
```
设置姓名为索引:
     性别  年龄  班级  数学  英语  物理
姓名
张三   男  18  一班  85  90  78
李四   女  19  一班  92  88  85
王五   男  18  二班  78  85  92
赵六   女  20  二班  88  92  80
钱七   男  19  一班  95  87  88
孙八   女  18  二班  73  78  85
周九   男  20  一班  90  93  82
吴十   女  19  二班  82  95  90
```

---

### loc选择单个元素

选择特定行和列交叉的单个单元格的值。

```python
# 选择张三的数学成绩
score = df_with_index.loc['张三', '数学']
print(f"张三的数学成绩: {score}")  # 85

# 选择李四的英语成绩
score = df_with_index.loc['李四', '英语']
print(f"李四的英语成绩: {score}")  # 88

# 类型是标量值
print(f"类型: {type(score)}")  # <class 'numpy.int64'>
```

**理解**：`loc['张三', '数学']` 就像在Excel中定位到"张三"行和"数学"列的交叉单元格。

```
        数学  英语  物理
张三 →   85   90   78   ← 定位到这个值
李四     92   88   85
王五     78   85   92
```

---

### loc选择整行

只指定行标签，不指定列，返回整行数据。

```python
# 选择张三的所有信息
zhang_san = df_with_index.loc['张三']
print("张三的所有信息:")
print(zhang_san)
print(f"类型: {type(zhang_san)}")  # Series

# 等价写法（显式指定所有列）
zhang_san = df_with_index.loc['张三', :]
print("\n等价写法:")
print(zhang_san)
```

输出：
```
张三的所有信息:
性别     男
年龄    18
班级    一班
数学    85
英语    90
物理    78
Name: 张三, dtype: object
类型: <class 'pandas.core.series.Series'>
```

**注意**：
- 返回的是Series，不是DataFrame
- Series的index是原DataFrame的列名
- Series的name是行标签'张三'

---

### loc选择多行

传入行标签列表，选择多行。

```python
# 选择张三和李四的所有信息
selected = df_with_index.loc[['张三', '李四']]
print("张三和李四的信息:")
print(selected)
print(f"类型: {type(selected)}")  # DataFrame

# 选择多个学生
selected = df_with_index.loc[['张三', '李四', '钱七']]
print("\n选择的学生:")
print(selected)
```

输出：
```
张三和李四的信息:
     性别  年龄  班级  数学  英语  物理
姓名
张三   男  18  一班  85  90  78
李四   女  19  一班  92  88  85
类型: <class 'pandas.core.frame.DataFrame'>
```

---

### loc选择整列

指定列标签，选择整列。

```python
# 选择数学列（所有行）
math = df_with_index.loc[:, '数学']
print("数学成绩:")
print(math)
print(f"类型: {type(math)}")  # Series

# 注意与[]的区别
math2 = df_with_index['数学']
print("\n用[]选择列:")
print(math2)
# 两种方式结果相同，但loc更明确
```

---

### loc选择多列

传入列名列表，选择多列。

```python
# 选择数学和英语两列（所有行）
subjects = df_with_index.loc[:, ['数学', '英语']]
print("数学和英语成绩:")
print(subjects)
print(f"类型: {type(subjects)}")  # DataFrame
```

输出：
```
数学和英语成绩:
     数学  英语
姓名
张三  85  90
李四  92  88
王五  78  85
赵六  88  92
钱七  95  87
孙八  73  78
周九  90  93
吴十  82  95
类型: <class 'pandas.core.frame.DataFrame'>
```

---

### loc选择特定行列组合

这是loc最强大的功能：同时指定行和列。

```python
# 选择张三和李四的数学和英语成绩
selected = df_with_index.loc[['张三', '李四'], ['数学', '英语']]
print("指定行列:")
print(selected)

# 选择单个学生的多门课程
scores = df_with_index.loc['钱七', ['数学', '英语', '物理']]
print("\n钱七的成绩:")
print(scores)

# 选择多个学生的单门课程
math_scores = df_with_index.loc[['张三', '李四', '王五'], '数学']
print("\n三个学生的数学成绩:")
print(math_scores)
```

输出：
```
指定行列:
     数学  英语
姓名
张三  85  90
李四  92  88

钱七的成绩:
数学    95
英语    87
物理    88
Name: 钱七, dtype: int64

三个学生的数学成绩:
姓名
张三    85
李四    92
王五    78
Name: 数学, dtype: int64
```

---

### loc的切片（重点！）

loc支持切片，但与Python列表切片不同，**loc的切片是两端都包含的**（闭区间）。

```python
# 行切片：从张三到王五（两端都包含）
sliced = df_with_index.loc['张三':'王五']
print("从张三到王五:")
print(sliced)

# 列切片：从数学到英语
sliced = df_with_index.loc[:, '数学':'英语']
print("\n从数学到英语列:")
print(sliced)

# 同时切片行和列
sliced = df_with_index.loc['张三':'赵六', '数学':'英语']
print("\n行列都切片:")
print(sliced)
```

输出：
```
从张三到王五:
     性别  年龄  班级  数学  英语  物理
姓名
张三   男  18  一班  85  90  78
李四   女  19  一班  92  88  85
王五   男  18  二班  78  85  92

从数学到英语列:
     数学  英语
姓名
张三  85  90
李四  92  88
王五  78  85
...

行列都切片:
     数学  英语
姓名
张三  85  90
李四  92  88
王五  78  85
赵六  88  92
```

**关键区别**：
```python
# Python列表切片：左闭右开
my_list = [1, 2, 3, 4, 5]
print(my_list[1:3])  # [2, 3]，不包含索引3

# loc切片：两端都包含（闭区间）
df_with_index.loc['张三':'王五']  # 包含张三、李四、王五
```

**为什么loc的切片是闭区间？**

因为loc使用的是标签，不是位置。当你说"从张三到王五"，自然是希望包含王五。如果是半开区间，你需要知道王五的下一个标签是什么，这很不直观。

---

### loc处理数字索引的陷阱

当DataFrame的行索引是数字时，要特别小心。

```python
# 原始df的索引是0, 1, 2, 3...
print("原始df的索引:", df.index.tolist())  # [0, 1, 2, 3, 4, 5, 6, 7]

# loc使用标签，即使标签是数字
row = df.loc[0]  # 选择标签为0的行
print("\nloc[0]:")
print(row)

# loc切片也是基于标签
sliced = df.loc[0:3]  # 标签0到3，两端都包含
print("\nloc[0:3]:")
print(sliced)  # 包含索引0, 1, 2, 3（4行）

# 对比：[]切片是基于位置
sliced = df[0:3]  # 位置0到3，左闭右开
print("\n[0:3]:")
print(sliced)  # 包含位置0, 1, 2（3行）
```

**重要区别**：
```python
# 当索引是0,1,2,3...时：
df.loc[0:3]   # 选择标签0,1,2,3（4行）- 闭区间
df[0:3]       # 选择位置0,1,2（3行）- 半开区间
```

这是很多初学者容易混淆的地方！

---

## iloc：基于位置的索引（重点！）

`iloc`是另一个重要的索引器，它基于**位置**（position）进行索引，完全类似于Python列表的切片。

### 理解iloc的核心概念

**iloc的语法**：`df.iloc[行位置, 列位置]`

- 行位置：整数位置，从0开始
- 列位置：整数位置，从0开始
- 支持单个值、列表、切片、布尔数组
- **切片是半开区间**（左闭右开），和Python列表一致

**iloc vs loc**：
- `loc`：基于标签，切片是闭区间
- `iloc`：基于位置，切片是半开区间

```python
# 继续使用之前的数据
print("数据预览:")
print(df.head())
print(f"\n形状: {df.shape}")  # (8, 7)
```

---

### iloc选择单个元素

使用行位置和列位置选择单个单元格。

```python
# 选择第0行第4列（第1个学生的数学成绩）
score = df.iloc[0, 4]
print(f"第0行第4列: {score}")  # 85

# 选择第1行第5列（第2个学生的英语成绩）
score = df.iloc[1, 5]
print(f"第1行第5列: {score}")  # 88

# 使用负数索引（从末尾计数）
score = df.iloc[-1, -1]  # 最后一行最后一列
print(f"最后一行最后一列: {score}")  # 90
```

**位置索引对照表**：
```
行位置:  0    1    2    3    4    5    6    7
      张三  李四  王五  赵六  钱七  孙八  周九  吴十

列位置:  0    1    2    3    4    5    6
       姓名  性别  年龄  班级  数学  英语  物理
```

---

### iloc选择整行

只指定行位置，选择整行。

```python
# 选择第0行（第一个学生）
first_row = df.iloc[0]
print("第0行:")
print(first_row)
print(f"类型: {type(first_row)}")  # Series

# 选择最后一行
last_row = df.iloc[-1]
print("\n最后一行:")
print(last_row)
```

输出：
```
第0行:
姓名    张三
性别     男
年龄    18
班级    一班
数学    85
英语    90
物理    78
Name: 0, dtype: object
类型: <class 'pandas.core.series.Series'>
```

---

### iloc选择多行

传入行位置列表，选择多行。

```python
# 选择第0行和第2行
selected = df.iloc[[0, 2]]
print("第0行和第2行:")
print(selected)

# 选择前3个学生
first_three = df.iloc[[0, 1, 2]]
print("\n前3个学生:")
print(first_three)

# 可以重复选择
repeated = df.iloc[[0, 0, 1, 1]]
print("\n重复选择:")
print(repeated)  # 第0行出现两次，第1行出现两次
```

---

### iloc选择整列

指定列位置，选择整列。

```python
# 选择第4列（数学）
math = df.iloc[:, 4]
print("第4列（数学）:")
print(math)
print(f"类型: {type(math)}")  # Series

# 选择最后一列（物理）
last_col = df.iloc[:, -1]
print("\n最后一列（物理）:")
print(last_col)
```

---

### iloc选择多列

传入列位置列表，选择多列。

```python
# 选择第4和第5列（数学和英语）
subjects = df.iloc[:, [4, 5]]
print("第4和第5列:")
print(subjects)

# 选择前3列
first_cols = df.iloc[:, [0, 1, 2]]
print("\n前3列:")
print(first_cols)
```

---

### iloc选择特定行列组合

同时指定行位置和列位置。

```python
# 选择前2个学生的数学和英语成绩
selected = df.iloc[[0, 1], [4, 5]]
print("前2个学生的数学和英语:")
print(selected)

# 选择第3个学生的所有科目成绩
scores = df.iloc[2, [4, 5, 6]]
print("\n第3个学生的成绩:")
print(scores)

# 选择特定的单元格
cells = df.iloc[[0, 2, 4], [0, 4]]  # 第0,2,4行的第0,4列
print("\n特定单元格:")
print(cells)
```

输出：
```
前2个学生的数学和英语:
   数学  英语
0  85  90
1  92  88

第3个学生的成绩:
数学    78
英语    85
物理    92
Name: 2, dtype: int64

特定单元格:
   姓名  数学
0  张三  85
2  王五  78
4  钱七  95
```

---

### iloc的切片（重点！）

iloc的切片和Python列表切片完全一样：**左闭右开**。

```python
# 行切片：前3行（位置0,1,2）
sliced = df.iloc[0:3]
print("前3行:")
print(sliced)

# 列切片：第4到第6列（位置4,5）
sliced = df.iloc[:, 4:6]
print("\n第4到第6列:")
print(sliced)

# 同时切片行和列
sliced = df.iloc[0:3, 4:7]  # 前3行，第4-6列
print("\n行列都切片:")
print(sliced)

# 使用步长
every_other = df.iloc[::2, :]  # 隔行取
print("\n隔行取值:")
print(every_other)

# 反转行
reversed_df = df.iloc[::-1, :]
print("\n反转行:")
print(reversed_df)
```

输出：
```
前3行:
   姓名 性别  年龄  班级  数学  英语  物理
0  张三  男  18  一班  85  90  78
1  李四  女  19  一班  92  88  85
2  王五  男  18  二班  78  85  92

第4到第6列:
   数学  英语
0  85  90
1  92  88
2  78  85
...

行列都切片:
   数学  英语  物理
0  85  90  78
1  92  88  85
2  78  85  92
```

**iloc切片规则**：
```python
df.iloc[0:3]     # 位置0,1,2（3行）- 不包含3
df.iloc[0:3, :]  # 前3行，所有列
df.iloc[:, 0:3]  # 所有行，前3列
df.iloc[1:5:2]   # 位置1,3（步长为2）
df.iloc[::-1]    # 反转行
```

---

### iloc常见用法总结

```python
# 1. 选择前n行
df.iloc[:5]         # 前5行
df.iloc[:10]        # 前10行

# 2. 选择后n行
df.iloc[-5:]        # 后5行
df.iloc[-10:]       # 后10行

# 3. 选择中间的行
df.iloc[10:20]      # 第10到19行

# 4. 选择特定列
df.iloc[:, 0]       # 第一列
df.iloc[:, -1]      # 最后一列
df.iloc[:, [0, 2]]  # 第0和第2列

# 5. 选择子矩阵
df.iloc[0:10, 0:3]  # 前10行，前3列

# 6. 隔行/隔列取值
df.iloc[::2, :]     # 每隔一行
df.iloc[:, ::2]     # 每隔一列

# 7. 随机抽样
import numpy as np
random_rows = np.random.choice(len(df), 5, replace=False)
df.iloc[random_rows]  # 随机选5行
```

---

## loc vs iloc：核心区别对比（超级重要！）

这是本章最重要的部分！很多初学者在这里犯迷糊。让我们通过对比和实例彻底搞清楚。

### 核心区别总结

| 特性 | loc | iloc |
|------|-----|------|
| **索引方式** | 基于标签（label） | 基于位置（position） |
| **行索引** | 使用行标签 | 使用整数位置（0,1,2...） |
| **列索引** | 使用列名 | 使用整数位置（0,1,2...） |
| **切片规则** | 闭区间（包含两端） | 半开区间（左闭右开） |
| **示例** | `df.loc['张三', '数学']` | `df.iloc[0, 4]` |

---

### 对比示例1：选择单个元素

```python
# 使用loc：标签索引
score_loc = df_with_index.loc['张三', '数学']
print(f"loc方式: {score_loc}")  # 85

# 使用iloc：位置索引
score_iloc = df.iloc[0, 4]
print(f"iloc方式: {score_iloc}")  # 85

# 结果相同，但方式不同
# loc: 我要"张三"行的"数学"列
# iloc: 我要第0行的第4列
```

---

### 对比示例2：选择整行

```python
# loc：使用行标签
row_loc = df_with_index.loc['张三']
print("loc选择张三:")
print(row_loc)

# iloc：使用行位置
row_iloc = df.iloc[0]
print("\niloc选择第0行:")
print(row_iloc)

# 结果相同（如果张三在第0行）
```

---

### 对比示例3：切片（重点！）

这是最容易混淆的地方。

```python
print("原始df的索引:", df.index.tolist())  # [0, 1, 2, 3, 4, 5, 6, 7]

# loc切片：闭区间
loc_slice = df.loc[0:3]
print("\nloc[0:3]:")
print(loc_slice)
print(f"形状: {loc_slice.shape}")  # (4, 7) - 包含0,1,2,3

# iloc切片：半开区间
iloc_slice = df.iloc[0:3]
print("\niloc[0:3]:")
print(iloc_slice)
print(f"形状: {iloc_slice.shape}")  # (3, 7) - 包含0,1,2

# 对比
print("\nloc[0:3]包含4行（索引0,1,2,3）")
print("iloc[0:3]包含3行（位置0,1,2）")
```

**关键区别**：
```python
# 当索引是0,1,2,3,4,5,6,7时：
df.loc[0:3]    # 标签0到标签3，闭区间 → 4行（0,1,2,3）
df.iloc[0:3]   # 位置0到位置3，半开区间 → 3行（0,1,2）

# 当索引是['a','b','c','d','e']时：
df.loc['a':'c']   # 标签a到标签c，闭区间 → 3行（a,b,c）
df.iloc[0:3]      # 位置0到位置3，半开区间 → 3行（a,b,c）
```

---

### 对比示例4：非数字索引

当索引不是数字时，区别更明显。

```python
# 设置字符串索引
df_str_index = df.set_index('姓名')
print("字符串索引的df:")
print(df_str_index.index.tolist())  # ['张三', '李四', '王五', ...]

# loc：使用标签
loc_result = df_str_index.loc['张三':'王五']
print("\nloc['张三':'王五']:")
print(loc_result)  # 包含张三、李四、王五

# iloc：只能使用位置
iloc_result = df_str_index.iloc[0:3]
print("\niloc[0:3]:")
print(iloc_result)  # 包含位置0,1,2

# iloc不认识字符串标签
try:
    df_str_index.iloc['张三']  # 报错！
except TypeError as e:
    print("\niloc不接受字符串:", e)

# loc不接受纯位置（当索引是字符串时）
# df_str_index.loc[0:3]  # 如果索引中没有0,1,2,3，会报错或返回空
```

---

### 对比示例5：选择列

```python
# loc：使用列名
col_loc = df.loc[:, '数学']
print("loc选择数学列:")
print(col_loc.head())

# iloc：使用列位置
col_iloc = df.iloc[:, 4]  # 数学在第4列（从0开始）
print("\niloc选择第4列:")
print(col_iloc.head())

# 多列
cols_loc = df.loc[:, ['数学', '英语']]
cols_iloc = df.iloc[:, [4, 5]]
print("\n两种方式选择多列，结果相同")
```

---

### 什么时候用loc，什么时候用iloc？

**使用loc的场景**：
1. 当你知道行/列的标签（名字）时
2. 当你想用有意义的名字来索引
3. 当你需要切片时希望包含两端
4. 数据分析中最常用（因为通常我们关心的是数据的含义）

```python
# 示例：选择特定学生的特定科目
df.loc[df['姓名'] == '张三', '数学']

# 选择一班学生
df.loc[df['班级'] == '一班']

# 选择多门课程
df.loc[:, ['数学', '英语', '物理']]
```

**使用iloc的场景**：
1. 当你需要按位置选择（如"前10行"、"最后5列"）
2. 当你需要规则的切片（如每隔2行）
3. 当你不关心标签，只关心位置
4. 数据预处理时常用

```python
# 示例：查看前5行
df.iloc[:5]

# 选择前3列和后3列
df.iloc[:, :3]
df.iloc[:, -3:]

# 每隔2行取样
df.iloc[::2]

# 随机抽样
random_indices = np.random.choice(len(df), 100)
df.iloc[random_indices]
```

**经验法则**：
- **优先使用loc**：代码更易读，语义更清晰
- **需要位置操作时用iloc**：如"前n个"、"每隔k个"

---

### 混合使用的陷阱

不要混合使用标签和位置！

```python
# 错误：混合使用
# df.loc[0, 4]  # 0是标签还是位置？4是列名还是位置？

# 正确：明确使用loc或iloc
df.loc[0, '数学']   # 明确：标签0，列名'数学'
df.iloc[0, 4]       # 明确：位置0，位置4

# loc可以混合标签和切片
df.loc[0:3, ['数学', '英语']]  # 标签0到3，列名

# iloc只用位置
df.iloc[0:3, [4, 5]]  # 位置0到2，位置4和5
```

---

## at和iat：快速访问单个值

`at`和`iat`是`loc`和`iloc`的快速版本，专门用于访问单个标量值。

### 为什么需要at和iat？

`loc`和`iloc`功能强大，但访问单个值时有性能开销。`at`和`iat`优化了这个场景，速度更快。

```python
import time

# 性能对比
n = 100000

# 使用loc
start = time.time()
for _ in range(n):
    value = df.loc[0, '数学']
time_loc = time.time() - start

# 使用at
start = time.time()
for _ in range(n):
    value = df.at[0, '数学']
time_at = time.time() - start

print(f"loc耗时: {time_loc:.4f}秒")
print(f"at耗时: {time_at:.4f}秒")
print(f"at速度提升: {time_loc/time_at:.2f}倍")
```

---

### at：基于标签的快速访问

`at`是`loc`的快速版本，只能访问单个值。

```python
# 访问单个值
score = df.at[0, '数学']
print(f"张三的数学成绩: {score}")  # 85

# 修改单个值
df.at[0, '数学'] = 100
print(f"修改后: {df.at[0, '数学']}")  # 100

# 恢复
df.at[0, '数学'] = 85

# at只能用于标量值
# df.at[0:2, '数学']  # 报错！at不支持切片
# df.at[[0, 1], '数学']  # 报错！at不支持列表
```

**使用场景**：
- 在循环中频繁访问/修改单个单元格时
- 确定只需要一个值时

```python
# 示例：更新特定学生的成绩
for index in df.index:
    if df.at[index, '姓名'] == '张三':
        df.at[index, '数学'] = 100
        break
```

---

### iat：基于位置的快速访问

`iat`是`iloc`的快速版本，只能访问单个值。

```python
# 访问单个值
score = df.iat[0, 4]  # 第0行第4列
print(f"第0行第4列: {score}")  # 85

# 修改单个值
df.iat[0, 4] = 100
print(f"修改后: {df.iat[0, 4]}")  # 100

# 恢复
df.iat[0, 4] = 85

# 使用负数索引
last_value = df.iat[-1, -1]
print(f"最后一个值: {last_value}")
```

**使用场景**：
- 按位置访问单个值时
- 性能关键的代码中

```python
# 示例：遍历每个单元格
for i in range(len(df)):
    for j in range(len(df.columns)):
        value = df.iat[i, j]
        # 处理value
```

---

### at/iat vs loc/iloc

| 特性 | at/iat | loc/iloc |
|------|--------|----------|
| **功能** | 只能访问单个值 | 支持各种选择 |
| **返回** | 标量值 | Series/DataFrame/标量 |
| **性能** | 更快 | 较慢 |
| **灵活性** | 有限 | 强大 |

**选择原则**：
- 需要单个值 + 性能敏感 → 用`at`/`iat`
- 其他情况 → 用`loc`/`iloc`

```python
# 单个值：优先at/iat
value = df.at[0, '数学']      # 推荐
value = df.loc[0, '数学']     # 也可以，但稍慢

# 多个值/切片：必须用loc/iloc
values = df.loc[0:2, '数学']  # 必须用loc
values = df.iloc[0:3, 4]      # 必须用iloc
```

---

## 布尔索引：条件筛选（超级重要！）

布尔索引是数据分析中最常用的功能之一，它允许你根据条件筛选数据。这在实际工作中太常见了！

### 什么是布尔索引？

布尔索引就是用布尔值（True/False）来选择数据。只有对应位置为True的数据会被选中。

```python
# 创建一个布尔Series
mask = df['数学'] > 85
print("布尔掩码:")
print(mask)
print(f"类型: {type(mask)}")
```

输出：
```
布尔掩码:
0    False
1     True
2    False
3     True
4     True
5    False
6     True
7    False
Name: 数学, dtype: bool
类型: <class 'pandas.core.series.Series'>
```

**理解布尔索引**：
```
原数据:  张三(85) 李四(92) 王五(78) 赵六(88) ...
条件>85:  False    True    False   True    ...
结果:    跳过     选中     跳过     选中    ...
```

---

### 基本条件筛选

```python
# 筛选数学成绩大于85的学生
high_math = df[df['数学'] > 85]
print("数学成绩>85的学生:")
print(high_math)

# 筛选一班的学生
class_one = df[df['班级'] == '一班']
print("\n一班学生:")
print(class_one)

# 筛选女生
girls = df[df['性别'] == '女']
print("\n女生:")
print(girls)

# 筛选年龄不等于18的学生
not_18 = df[df['年龄'] != 18]
print("\n年龄不是18的学生:")
print(not_18)
```

输出：
```
数学成绩>85的学生:
   姓名 性别  年龄  班级  数学  英语  物理
1  李四  女  19  一班  92  88  85
3  赵六  女  20  二班  88  92  80
4  钱七  男  19  一班  95  87  88
6  周九  男  20  一班  90  93  82

一班学生:
   姓名 性别  年龄  班级  数学  英语  物理
0  张三  男  18  一班  85  90  78
1  李四  女  19  一班  92  88  85
4  钱七  男  19  一班  95  87  88
6  周九  男  20  一班  90  93  82
```

---

### 常用比较运算符

```python
# 大于
df[df['数学'] > 85]

# 大于等于
df[df['数学'] >= 90]

# 小于
df[df['年龄'] < 20]

# 小于等于
df[df['英语'] <= 85]

# 等于（注意是两个等号）
df[df['班级'] == '一班']

# 不等于
df[df['性别'] != '男']

# 字符串包含
df[df['姓名'].str.contains('三')]

# 在列表中
df[df['姓名'].isin(['张三', '李四', '王五'])]

# 不在列表中
df[~df['姓名'].isin(['张三', '李四'])]
```

---

### 字符串条件

处理字符串列时的常用条件。

```python
# 包含某个字符
contains_san = df[df['姓名'].str.contains('三')]
print("名字包含'三'的学生:")
print(contains_san)

# 以某字符开头
starts_with = df[df['姓名'].str.startswith('张')]
print("\n姓张的学生:")
print(starts_with)

# 以某字符结尾
ends_with = df[df['姓名'].str.endswith('四')]
print("\n名字以'四'结尾:")
print(ends_with)

# 字符串长度
two_chars = df[df['姓名'].str.len() == 2]
print("\n名字是2个字的学生:")
print(two_chars)

# 在列表中
selected = df[df['姓名'].isin(['张三', '李四', '王五'])]
print("\n指定的几个学生:")
print(selected)
```

---

## 多条件筛选：组合条件（重中之重！）

实际工作中，我们经常需要组合多个条件。Pandas使用`&`（与）、`|`（或）、`~`（非）来组合条件。

### 重要提示：必须用&、|、~

**不能使用Python的and、or、not！**

```python
# 错误写法（会报错）
# df[df['数学'] > 85 and df['英语'] > 90]  # 报错！

# 正确写法
df[(df['数学'] > 85) & (df['英语'] > 90)]  # 正确
```

**为什么？**

`and`/`or`/`not`是Python的关键字，用于单个布尔值。而`&`/`|`/`~`是按位运算符，被Pandas重载用于Series的元素级运算。

**注意括号！**

每个条件必须用括号包起来，因为`&`/`|`的优先级高于比较运算符。

```python
# 错误：没有括号
# df[df['数学'] > 85 & df['英语'] > 90]  # 报错！

# 正确：加括号
df[(df['数学'] > 85) & (df['英语'] > 90)]
```

---

### & 操作符：同时满足多个条件（AND）

```python
# 条件1：数学成绩大于85
# 条件2：英语成绩大于90
# 两个条件都要满足
high_both = df[(df['数学'] > 85) & (df['英语'] > 90)]
print("数学>85且英语>90:")
print(high_both)

# 三个条件
excellent = df[(df['数学'] > 85) & (df['英语'] > 85) & (df['物理'] > 85)]
print("\n三科都优秀:")
print(excellent)

# 条件：一班的男生
class_one_boys = df[(df['班级'] == '一班') & (df['性别'] == '男')]
print("\n一班的男生:")
print(class_one_boys)

# 条件：年龄在18-19之间（包含）
age_range = df[(df['年龄'] >= 18) & (df['年龄'] <= 19)]
print("\n年龄18-19:")
print(age_range)
```

输出：
```
数学>85且英语>90:
   姓名 性别  年龄  班级  数学  英语  物理
1  李四  女  19  一班  92  88  85
3  赵六  女  20  二班  88  92  80
6  周九  男  20  一班  90  93  82
7  吴十  女  19  二班  82  95  90

一班的男生:
   姓名 性别  年龄  班级  数学  英语  物理
0  张三  男  18  一班  85  90  78
4  钱七  男  19  一班  95  87  88
6  周九  男  20  一班  90  93  82
```

---

### | 操作符：满足任一条件（OR）

```python
# 条件1：数学成绩大于90
# 条件2：英语成绩大于90
# 满足其中一个即可
high_any = df[(df['数学'] > 90) | (df['英语'] > 90)]
print("数学>90或英语>90:")
print(high_any)

# 条件：一班或二班
both_classes = df[(df['班级'] == '一班') | (df['班级'] == '二班')]
print("\n一班或二班:")
print(both_classes)  # 其实就是全部学生

# 条件：年龄小于19或大于19
not_19 = df[(df['年龄'] < 19) | (df['年龄'] > 19)]
print("\n年龄不是19:")
print(not_19)

# 实际应用：找出任一科目不及格的学生（假设60分及格）
fail_any = df[(df['数学'] < 60) | (df['英语'] < 60) | (df['物理'] < 60)]
print("\n任一科目不及格:")
print(fail_any if len(fail_any) > 0 else "没有不及格的学生")
```

---

### ~ 操作符：取反（NOT）

```python
# 取反：不是一班的学生
not_class_one = df[~(df['班级'] == '一班')]
print("不是一班的学生:")
print(not_class_one)

# 等价于
not_class_one = df[df['班级'] != '一班']

# 取反：数学成绩不大于85（即<=85）
not_high_math = df[~(df['数学'] > 85)]
print("\n数学<=85:")
print(not_high_math)

# 组合使用：不是(数学>85且英语>90)
not_excellent = df[~((df['数学'] > 85) & (df['英语'] > 90))]
print("\n不是数学>85且英语>90:")
print(not_excellent)
```

---

### 复杂条件组合

实际工作中经常需要组合多个条件。

```python
# 条件：(数学>85或英语>90) 且 性别='女'
complex1 = df[((df['数学'] > 85) | (df['英语'] > 90)) & (df['性别'] == '女')]
print("(数学>85或英语>90)且是女生:")
print(complex1)

# 条件：一班的(数学>90或英语>90)的学生
complex2 = df[(df['班级'] == '一班') & ((df['数学'] > 90) | (df['英语'] > 90))]
print("\n一班中数学或英语>90:")
print(complex2)

# 条件：不是一班的男生
complex3 = df[~((df['班级'] == '一班') & (df['性别'] == '男'))]
print("\n不是一班的男生:")
print(complex3)

# 条件：年龄在18-19之间，且任一科目>90
complex4 = df[((df['年龄'] >= 18) & (df['年龄'] <= 19)) &
              ((df['数学'] > 90) | (df['英语'] > 90) | (df['物理'] > 90))]
print("\n年龄18-19且任一科>90:")
print(complex4)
```

---

### 使用isin()简化条件

当需要匹配多个值时，用`isin()`比多个`|`更简洁。

```python
# 用|连接多个条件（繁琐）
selected = df[(df['姓名'] == '张三') | (df['姓名'] == '李四') | (df['姓名'] == '王五')]

# 用isin()（推荐）
selected = df[df['姓名'].isin(['张三', '李四', '王五'])]
print("选择的学生:")
print(selected)

# 不在列表中：用~
not_selected = df[~df['姓名'].isin(['张三', '李四'])]
print("\n不是张三李四:")
print(not_selected)

# 多列条件
selected = df[df['班级'].isin(['一班', '二班'])]  # 一班或二班
```

---

### between()：范围筛选

筛选数值在某个范围内的数据。

```python
# 数学成绩在80-90之间
math_range = df[df['数学'].between(80, 90)]
print("数学成绩80-90:")
print(math_range)

# 包含边界（默认）
math_range = df[df['数学'].between(80, 90, inclusive='both')]  # 80<=数学<=90

# 不包含边界
math_range = df[df['数学'].between(80, 90, inclusive='neither')]  # 80<数学<90

# 左闭右开
math_range = df[df['数学'].between(80, 90, inclusive='left')]  # 80<=数学<90

# 左开右闭
math_range = df[df['数学'].between(80, 90, inclusive='right')]  # 80<数学<=90

# 年龄范围
age_range = df[df['年龄'].between(18, 19)]
print("\n年龄18-19:")
print(age_range)
```

---

### 实战案例：成绩分析

```python
# 案例1：找出优秀学生（三科平均>85）
df['平均分'] = df[['数学', '英语', '物理']].mean(axis=1)
excellent_students = df[df['平均分'] > 85]
print("优秀学生（平均>85）:")
print(excellent_students[['姓名', '数学', '英语', '物理', '平均分']])

# 案例2：找出偏科学生（最高分-最低分>15）
df['最高分'] = df[['数学', '英语', '物理']].max(axis=1)
df['最低分'] = df[['数学', '英语', '物理']].min(axis=1)
df['分差'] = df['最高分'] - df['最低分']
biased = df[df['分差'] > 15]
print("\n偏科学生:")
print(biased[['姓名', '数学', '英语', '物理', '分差']])

# 案例3：找出需要辅导的学生（任一科<80）
need_help = df[(df['数学'] < 80) | (df['英语'] < 80) | (df['物理'] < 80)]
print("\n需要辅导的学生:")
print(need_help[['姓名', '数学', '英语', '物理']])

# 案例4：一班中数学前3名
class_one = df[df['班级'] == '一班'].copy()
class_one_top3 = class_one.nlargest(3, '数学')
print("\n一班数学前3名:")
print(class_one_top3[['姓名', '数学']])

# 清理临时列
df = df.drop(['平均分', '最高分', '最低分', '分差'], axis=1)
```

---

## query()方法：字符串表达式查询

`query()`方法允许你用字符串表达式来筛选数据，代码更简洁、更接近SQL风格。

### query()基本用法

```python
# 传统方式
result = df[df['数学'] > 85]

# query方式
result = df.query('数学 > 85')
print("数学>85:")
print(result)

# 多个条件
result = df.query('数学 > 85 and 英语 > 85')
print("\n数学>85且英语>85:")
print(result)

# 或条件
result = df.query('数学 > 90 or 英语 > 90')
print("\n数学>90或英语>90:")
print(result)
```

---

### query()的优势

1. **代码更简洁**：不需要重复写`df`
2. **更接近自然语言**：可以用`and`/`or`/`not`
3. **性能更好**：对大数据集优化

```python
# 传统方式：繁琐
result = df[(df['数学'] > 85) & (df['英语'] > 85) & (df['物理'] > 85)]

# query方式：简洁
result = df.query('数学 > 85 and 英语 > 85 and 物理 > 85')
print("三科都>85:")
print(result)

# 复杂条件
result = df.query('(数学 > 85 or 英语 > 90) and 性别 == "女"')
print("\n(数学>85或英语>90)且是女生:")
print(result)
```

---

### query()使用变量

在query中使用Python变量，需要加`@`符号。

```python
# 定义阈值
math_threshold = 85
english_threshold = 90

# 使用变量（加@）
result = df.query('数学 > @math_threshold and 英语 > @english_threshold')
print(f"数学>{math_threshold}且英语>{english_threshold}:")
print(result)

# 使用列表
names = ['张三', '李四', '王五']
result = df.query('姓名 in @names')
print("\n指定学生:")
print(result)

# 字符串变量
class_name = '一班'
result = df.query('班级 == @class_name')
print(f"\n{class_name}学生:")
print(result)
```

---

### query()的限制

1. 列名不能有空格（或需要用反引号）
2. 某些复杂表达式不支持
3. 对初学者可能不够直观

```python
# 列名有空格时需要用反引号
# df_with_space = df.copy()
# df_with_space.columns = ['姓 名', '性 别', ...]
# result = df_with_space.query('`姓 名` == "张三"')

# 复杂表达式可能需要传统方式
# 如字符串方法：df['姓名'].str.contains('三')
# query中比较难表达
```

---

### query() vs 传统方式对比

```python
# 示例1：简单条件
# 传统
result1 = df[df['数学'] > 85]
# query
result2 = df.query('数学 > 85')

# 示例2：多条件
# 传统
result1 = df[(df['数学'] > 85) & (df['英语'] > 85)]
# query
result2 = df.query('数学 > 85 and 英语 > 85')

# 示例3：复杂条件
# 传统
result1 = df[((df['数学'] > 85) | (df['英语'] > 90)) & (df['性别'] == '女')]
# query
result2 = df.query('(数学 > 85 or 英语 > 90) and 性别 == "女"')

# query更简洁！
```

**建议**：
- 简单条件：用query，更简洁
- 复杂条件或需要字符串方法：用传统方式
- 看个人喜好和团队规范

---

## 切片操作详解

Pandas的切片操作非常灵活，但也容易混淆。让我们系统梳理。

### 行切片（使用[]）

```python
# 基本行切片
first_three = df[0:3]  # 前3行（位置0,1,2）
print("前3行:")
print(first_three)

# 后n行
last_two = df[-2:]
print("\n后2行:")
print(last_two)

# 中间行
middle = df[2:5]
print("\n第3-5行:")
print(middle)

# 步长切片
every_other = df[::2]  # 每隔一行
print("\n每隔一行:")
print(every_other)

# 反转
reversed_df = df[::-1]
print("\n反转:")
print(reversed_df)
```

---

### 使用loc切片

```python
# loc按标签切片（闭区间）
sliced = df.loc[0:3]  # 标签0到3，包含3
print("loc[0:3]:")
print(sliced)  # 4行

# loc切片列
sliced = df.loc[:, '数学':'物理']  # 从数学到物理列
print("\nloc列切片:")
print(sliced)

# 同时切片行和列
sliced = df.loc[0:3, '姓名':'年龄']
print("\n行列都切片:")
print(sliced)
```

---

### 使用iloc切片

```python
# iloc按位置切片（半开区间）
sliced = df.iloc[0:3]  # 位置0到2，不包含3
print("iloc[0:3]:")
print(sliced)  # 3行

# iloc切片列
sliced = df.iloc[:, 4:7]  # 第4-6列（数学、英语、物理）
print("\niloc列切片:")
print(sliced)

# 同时切片行和列
sliced = df.iloc[0:3, 0:3]  # 前3行，前3列
print("\n行列都切片:")
print(sliced)

# 负数切片
sliced = df.iloc[-3:, -3:]  # 后3行，后3列
print("\n后3行后3列:")
print(sliced)
```

---

### 切片对比总结

```python
# []切片：只能切行，半开区间
df[0:3]        # 位置0,1,2（3行）

# loc切片：行列都可以，闭区间，基于标签
df.loc[0:3]           # 标签0,1,2,3（4行，如果标签是0,1,2,3）
df.loc[:, '数学':'物理']  # 数学、英语、物理列
df.loc[0:3, '数学':'物理']  # 行列都切片

# iloc切片：行列都可以，半开区间，基于位置
df.iloc[0:3]       # 位置0,1,2（3行）
df.iloc[:, 4:7]    # 位置4,5,6（3列）
df.iloc[0:3, 4:7]  # 行列都切片
```

---

## 多级索引入门

多级索引（MultiIndex）是Pandas的高级特性，允许在行或列上有多层索引。这在分组数据和层次化数据中很有用。

### 创建多级索引

```python
# 方式1：从数组创建
arrays = [
    ['一班', '一班', '二班', '二班'],
    ['张三', '李四', '王五', '赵六']
]
index = pd.MultiIndex.from_arrays(arrays, names=['班级', '姓名'])

scores = pd.DataFrame({
    '数学': [85, 92, 78, 88],
    '英语': [90, 88, 85, 92]
}, index=index)

print("多级索引DataFrame:")
print(scores)
```

输出：
```
多级索引DataFrame:
           数学  英语
班级 姓名
一班 张三   85  90
    李四   92  88
二班 王五   78  85
    赵六   88  92
```

---

### 选择多级索引的数据

```python
# 选择一级索引
class_one = scores.loc['一班']
print("一班数据:")
print(class_one)

# 选择二级索引（需要元组）
zhang_san = scores.loc[('一班', '张三')]
print("\n张三的成绩:")
print(zhang_san)

# 使用切片
sliced = scores.loc['一班':'二班']
print("\n切片:")
print(sliced)

# 跨级选择（使用xs方法）
wang_wu = scores.xs('王五', level='姓名')
print("\n王五的成绩:")
print(wang_wu)
```

---

### 使用set_index创建多级索引

```python
# 将普通DataFrame转为多级索引
df_multi = df.set_index(['班级', '姓名'])
print("多级索引df:")
print(df_multi)

# 选择数据
print("\n一班的数据:")
print(df_multi.loc['一班'])

# 选择特定学生
print("\n一班张三:")
print(df_multi.loc[('一班', '张三')])

# 重置索引
df_reset = df_multi.reset_index()
print("\n重置索引:")
print(df_reset)
```

---

### 多级索引的实际应用

多级索引在以下场景特别有用：

1. **分组数据**：按班级、年级等分组
2. **时间序列**：日期+小时的组合索引
3. **实验数据**：实验组+样本编号
4. **地理数据**：国家+城市

```python
# 示例：按班级和性别分组统计
grouped = df.groupby(['班级', '性别'])['数学'].mean()
print("按班级和性别分组的数学平均分:")
print(grouped)
```

---

## 链式索引的陷阱（重要警告！）

链式索引是Pandas中一个常见的陷阱，会导致不可预期的结果或警告。

### 什么是链式索引？

链式索引是指连续使用多个索引操作，例如 `df[condition][column]`。

```python
# 链式索引示例（不推荐！）
# df[df['数学'] > 85]['英语'] = 100  # 可能不会修改原df！
```

---

### 为什么链式索引有问题？

因为中间步骤可能返回副本（copy）而不是视图（view），导致修改不生效。

```python
import warnings
warnings.simplefilter('default')  # 显示警告

# 创建测试数据
df_test = df.copy()

# 错误方式：链式索引
try:
    df_test[df_test['数学'] > 85]['英语'] = 100
    # 会看到SettingWithCopyWarning警告
except Exception as e:
    print(f"错误: {e}")

# 检查是否修改成功
print("链式索引后:")
print(df_test[df_test['数学'] > 85][['姓名', '数学', '英语']])
# 英语列可能没有改成100！
```

---

### 正确的方式

使用`loc`进行修改，避免链式索引。

```python
# 正确方式1：使用loc
df_test = df.copy()
df_test.loc[df_test['数学'] > 85, '英语'] = 100
print("使用loc修改:")
print(df_test[df_test['数学'] > 85][['姓名', '数学', '英语']])
# 英语列成功改成100

# 正确方式2：先筛选，再修改
df_test = df.copy()
mask = df_test['数学'] > 85
df_test.loc[mask, '英语'] = 100

# 正确方式3：使用query和loc结合
df_test = df.copy()
df_test.loc[df_test.query('数学 > 85').index, '英语'] = 100
```

---

### 链式索引的常见错误

```python
# 错误1：链式赋值
# df[df['数学'] > 85]['英语'] = 100  # 不推荐

# 正确1：用loc
df.loc[df['数学'] > 85, '英语'] = 100

# 错误2：多次索引
# high_math = df[df['数学'] > 85]
# high_math['英语'] = 100  # 可能修改的是副本

# 正确2：直接在原df上操作
df.loc[df['数学'] > 85, '英语'] = 100

# 错误3：嵌套索引
# df['数学'][0] = 100  # 不推荐

# 正确3：使用loc或at
df.loc[0, '数学'] = 100
# 或
df.at[0, '数学'] = 100
```

---

### 判断是视图还是副本

```python
# 使用_is_view属性（pandas内部属性）
sliced = df[0:3]
print(f"是否是视图: {sliced._is_view}")  # 可能是True

# 花式索引返回副本
fancy = df.iloc[[0, 2, 4]]
print(f"是否是视图: {fancy._is_view}")  # 通常是False

# 但这个属性不是公开API，不建议依赖它
```

---

### 最佳实践

1. **优先使用loc/iloc**：明确、安全
2. **避免链式索引**：特别是赋值时
3. **如果需要副本**：显式调用`.copy()`
4. **注意警告信息**：SettingWithCopyWarning

```python
# 推荐的写法
# 筛选并修改
df.loc[condition, column] = value

# 先筛选，再操作（如果需要多次操作）
subset = df[condition].copy()  # 显式copy
subset[column] = value

# 不推荐的写法
# df[condition][column] = value  # 链式索引
# df['col1']['col2'] = value     # 嵌套索引
```

---

## 选择数据的最佳实践

经过上面的学习，让我们总结一下实际工作中的最佳实践。

### 原则1：优先使用loc和iloc

```python
# 推荐：使用loc（标签索引）
df.loc[0, '数学']           # 单个值
df.loc[0:3, '数学':'英语']   # 切片
df.loc[condition, columns]  # 条件筛选

# 推荐：使用iloc（位置索引）
df.iloc[0, 4]        # 单个值
df.iloc[0:3, 4:6]    # 切片
df.iloc[rows, cols]  # 位置组合

# 不太推荐：[]操作符（语义不清晰）
df['数学']     # 可以用，但不够明确
df[0:3]        # 可以用，但功能有限
```

---

### 原则2：条件筛选用布尔索引

```python
# 推荐：清晰的布尔索引
high_math = df[df['数学'] > 85]
excellent = df[(df['数学'] > 85) & (df['英语'] > 85)]

# 推荐：结合loc使用
df.loc[df['数学'] > 85, ['姓名', '数学']]

# 推荐：query方法（简单条件时）
df.query('数学 > 85 and 英语 > 85')
```

---

### 原则3：修改数据用loc

```python
# 推荐：用loc修改
df.loc[0, '数学'] = 100
df.loc[df['数学'] > 85, '英语'] = 100

# 推荐：用at修改单个值（快速）
df.at[0, '数学'] = 100

# 不推荐：链式索引
# df[df['数学'] > 85]['英语'] = 100
```

---

### 原则4：明确是副本还是视图

```python
# 需要独立数据：显式copy
subset = df[df['数学'] > 85].copy()
subset['英语'] = 100  # 不影响原df

# 需要修改原数据：用loc
df.loc[df['数学'] > 85, '英语'] = 100
```

---

### 原则5：选择合适的方法

根据场景选择最合适的方法：

```python
# 场景1：选择列
df['数学']              # 单列，简单
df[['数学', '英语']]    # 多列，简单
df.loc[:, '数学']      # 明确，推荐

# 场景2：选择行
df.iloc[0]             # 按位置，推荐
df.loc[0]              # 按标签，推荐
df[0:1]                # 可以，但不如上面清晰

# 场景3：条件筛选
df[df['数学'] > 85]    # 简单条件，推荐
df.query('数学 > 85')  # 简洁，推荐
df.loc[condition]      # 复杂条件，推荐

# 场景4：选择子集
df.loc[rows, cols]     # 标签，推荐
df.iloc[rows, cols]    # 位置，推荐

# 场景5：单个值
df.at[row, col]        # 快速，推荐
df.iat[row, col]       # 快速，推荐
df.loc[row, col]       # 通用，也可以
```

---

### 原则6：代码可读性优先

```python
# 不好：难以理解
result = df[(df.iloc[:, 4] > 85) & (df.iloc[:, 5] > 85)].iloc[:, [0, 4, 5]]

# 好：清晰易读
math_high = df['数学'] > 85
english_high = df['英语'] > 85
result = df[math_high & english_high][['姓名', '数学', '英语']]

# 更好：使用query
result = df.query('数学 > 85 and 英语 > 85')[['姓名', '数学', '英语']]
```

---

## 实战练习题

通过练习巩固所学知识。下面是5个实战练习，涵盖本章的主要内容。

### 练习1：基础选择操作

给定以下学生数据，完成各项任务：

```python
# 数据准备
students = {
    '学号': [1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010],
    '姓名': ['张三', '李四', '王五', '赵六', '钱七', '孙八', '周九', '吴十', '郑一', '王二'],
    '性别': ['男', '女', '男', '女', '男', '女', '男', '女', '男', '女'],
    '年级': [1, 1, 2, 2, 3, 3, 1, 2, 3, 1],
    '语文': [88, 92, 78, 95, 85, 90, 82, 88, 91, 86],
    '数学': [85, 88, 92, 87, 90, 84, 88, 91, 86, 89],
    '英语': [90, 85, 88, 92, 87, 89, 91, 85, 88, 90]
}
df_students = pd.DataFrame(students)
```

**任务**：

1. 选择"姓名"和"语文"两列
2. 选择前5行数据
3. 选择第3到第7行（包含第7行）
4. 选择学号为1003的学生的所有信息
5. 选择第5个学生的数学成绩
6. 选择所有女生的姓名和英语成绩

**提示**：
- 使用`[]`选择列
- 使用`iloc`选择位置
- 使用`loc`结合条件筛选

---

### 练习2：条件筛选

继续使用练习1的数据，完成以下筛选任务：

**任务**：

1. 筛选语文成绩大于90分的学生
2. 筛选三科成绩都大于85分的学生
3. 筛选1年级或3年级的学生
4. 筛选不是2年级的女生
5. 筛选任一科目成绩大于90分的学生
6. 筛选姓"王"的学生（提示：使用`str.startswith()`）

**提示**：
- 使用`&`、`|`、`~`组合条件
- 注意括号
- 可以使用`.str`访问字符串方法

---

### 练习3：loc和iloc对比

给定数据，分别使用loc和iloc完成相同的任务：

```python
# 设置姓名为索引
df_indexed = df_students.set_index('姓名')
```

**任务**：

1. 使用loc选择"张三"的所有信息
2. 使用iloc选择第一个学生的所有信息
3. 使用loc选择"张三"到"赵六"的数据（包含两端）
4. 使用iloc选择前4个学生的数据
5. 使用loc选择"李四"和"王五"的"语文"和"数学"成绩
6. 使用iloc选择第2和第3个学生的第4和第5列

**思考**：
- loc和iloc在切片上有什么不同？
- 什么时候用loc，什么时候用iloc？

---

### 练习4：复杂条件筛选

继续使用学生数据，完成以下复杂筛选：

**任务**：

1. 找出三科平均分大于88分的学生
2. 找出偏科严重的学生（最高分-最低分>10）
3. 找出1年级中语文和数学都大于85分的学生
4. 找出女生中任一科目低于85分的学生
5. 找出3年级中三科成绩都在85-92分之间的学生
6. 使用query方法筛选2年级且数学成绩>90的学生

**提示**：
- 先计算平均分、最高分、最低分等辅助列
- 使用`between()`方法判断范围
- 尝试用query简化代码

---

### 练习5：综合实战 - 销售数据分析

给定一个销售数据集，完成数据分析任务：

```python
# 销售数据
sales_data = {
    '日期': pd.date_range('2024-01-01', periods=20, freq='D'),
    '产品': ['A', 'B', 'C', 'A', 'B'] * 4,
    '地区': ['北京', '上海', '广州', '深圳', '成都'] * 4,
    '销售额': np.random.randint(1000, 5000, 20),
    '销量': np.random.randint(10, 100, 20),
    '客户数': np.random.randint(5, 50, 20)
}
df_sales = pd.DataFrame(sales_data)
```

**任务**：

1. 筛选销售额大于3000的记录
2. 筛选产品A在北京的销售记录
3. 找出销量最高的前5条记录
4. 筛选1月1日到1月10日的数据
5. 找出每个地区销售额最高的记录
6. 筛选销售额大于3000且销量大于50的记录
7. 找出销售额在2000-4000之间的记录
8. 计算每个产品的总销售额，并筛选出总销售额前2名的产品

**提示**：
- 使用`nlargest()`找出最大值
- 日期筛选可以用布尔索引
- 分组统计用`groupby()`

---

### 练习答案提示

**练习1答案提示**：
```python
# 1. 选择列
df_students[['姓名', '语文']]

# 2. 前5行
df_students.iloc[:5]
# 或
df_students.head(5)

# 3. 第3到第7行
df_students.iloc[2:7]

# 4. 学号1003
df_students[df_students['学号'] == 1003]

# 5. 第5个学生的数学
df_students.iloc[4]['数学']
# 或
df_students.loc[4, '数学']

# 6. 女生的姓名和英语
df_students[df_students['性别'] == '女'][['姓名', '英语']]
# 或
df_students.loc[df_students['性别'] == '女', ['姓名', '英语']]
```

**练习2答案提示**：
```python
# 1. 语文>90
df_students[df_students['语文'] > 90]

# 2. 三科都>85
df_students[(df_students['语文'] > 85) &
            (df_students['数学'] > 85) &
            (df_students['英语'] > 85)]

# 3. 1年级或3年级
df_students[df_students['年级'].isin([1, 3])]
# 或
df_students[(df_students['年级'] == 1) | (df_students['年级'] == 3)]

# 4. 不是2年级的女生
df_students[(df_students['年级'] != 2) & (df_students['性别'] == '女')]

# 5. 任一科>90
df_students[(df_students['语文'] > 90) |
            (df_students['数学'] > 90) |
            (df_students['英语'] > 90)]

# 6. 姓王
df_students[df_students['姓名'].str.startswith('王')]
```

**练习3答案提示**：
```python
# 1-2. 第一个学生
df_indexed.loc['张三']
df_students.iloc[0]

# 3-4. 切片
df_indexed.loc['张三':'赵六']  # 包含两端
df_students.iloc[0:4]  # 不包含4

# 5-6. 特定行列
df_indexed.loc[['李四', '王五'], ['语文', '数学']]
df_students.iloc[[1, 2], [4, 5]]
```

---

## 本章总结

恭喜你完成了Pandas数据选择和索引的学习！这是Pandas中最重要、最基础的内容。让我们回顾一下要点：

### 核心知识点

1. **[]操作符**：
   - 选择列：`df['列名']`或`df[['列1', '列2']]`
   - 切片行：`df[0:5]`
   - 简单但功能有限

2. **loc：基于标签的索引**：
   - 语法：`df.loc[行标签, 列标签]`
   - 切片是闭区间（包含两端）
   - 最常用、最推荐

3. **iloc：基于位置的索引**：
   - 语法：`df.iloc[行位置, 列位置]`
   - 切片是半开区间（左闭右开）
   - 位置操作时使用

4. **at和iat：快速访问单个值**：
   - `at`是`loc`的快速版
   - `iat`是`iloc`的快速版
   - 性能敏感时使用

5. **布尔索引：条件筛选**：
   - 用True/False数组筛选数据
   - 实际工作中最常用
   - 使用`&`、`|`、`~`组合条件

6. **多条件筛选**：
   - 必须用`&`、`|`、`~`，不能用and/or/not
   - 每个条件必须加括号
   - 可以用`isin()`、`between()`简化

7. **query()方法**：
   - 字符串表达式查询
   - 代码更简洁
   - 可以用and/or

8. **链式索引陷阱**：
   - 避免`df[condition][column] = value`
   - 使用`df.loc[condition, column] = value`
   - 显式使用`.copy()`

---

### loc vs iloc 核心区别

| 特性 | loc | iloc |
|------|-----|------|
| 索引方式 | 标签 | 位置 |
| 行索引 | 行标签 | 整数位置 |
| 列索引 | 列名 | 整数位置 |
| 切片 | 闭区间 | 半开区间 |
| 示例 | `df.loc['A', 'col']` | `df.iloc[0, 1]` |

---

### 选择方法速查表

```python
# 选择列
df['col']                  # 单列，Series
df[['col1', 'col2']]       # 多列，DataFrame

# 选择行
df[0:5]                    # 切片，前5行
df.iloc[0]                 # 位置，第一行
df.loc[label]              # 标签，特定行

# 选择单元格
df.loc[row, col]           # 标签
df.iloc[row, col]          # 位置
df.at[row, col]            # 标签，快速
df.iat[row, col]           # 位置，快速

# 条件筛选
df[df['col'] > 5]          # 布尔索引
df.loc[condition]          # loc + 条件
df.query('col > 5')        # query方法

# 组合选择
df.loc[rows, cols]         # 标签
df.iloc[rows, cols]        # 位置
df.loc[condition, cols]    # 条件 + 列
```

---

### 最佳实践建议

1. **优先使用loc/iloc**：代码更清晰、更明确
2. **避免链式索引**：防止意外行为
3. **明确副本和视图**：需要独立数据时显式`.copy()`
4. **注意切片区别**：loc闭区间，iloc半开区间
5. **善用布尔索引**：条件筛选的首选方式
6. **代码可读性优先**：宁愿多写几行，也要清晰

---

### 常见错误总结

1. **混淆loc和iloc**：记住loc用标签，iloc用位置
2. **忘记括号**：布尔条件必须加括号
3. **用and/or**：应该用`&`、`|`
4. **链式索引**：赋值时避免链式索引
5. **切片区别**：loc包含两端，iloc不包含末端

---

### 实用技巧

```python
# 1. 查看前n行
df.head()           # 默认5行
df.iloc[:10]        # 前10行

# 2. 随机抽样
df.sample(n=10)     # 随机10行
df.sample(frac=0.1) # 随机10%

# 3. 最大/最小值行
df.nlargest(5, 'col')   # 最大5行
df.nsmallest(5, 'col')  # 最小5行

# 4. 条件统计
(df['col'] > 5).sum()   # 满足条件的行数
df[df['col'] > 5].shape[0]  # 同上

# 5. 多条件简化
df[df['col'].isin([1,2,3])]  # 替代多个or
df[df['col'].between(1, 10)]  # 替代and
```

---

### 下一步

掌握了数据选择和索引，你已经具备了操作Pandas数据的核心能力！下一章我们将学习**数据清洗**，包括：

- 处理缺失值
- 删除重复数据
- 数据类型转换
- 异常值处理
- 字符串清洗

这些内容将让你能够处理真实世界中的"脏数据"，为后续的数据分析做好准备！

---

**本章重点回顾**：

- `[]`操作符：基础选择
- `loc`：标签索引（闭区间），推荐使用
- `iloc`：位置索引（半开区间），位置操作
- `at`/`iat`：快速访问单个值
- 布尔索引：条件筛选，实战必备
- 多条件：用`&`、`|`、`~`，加括号
- `query()`：字符串表达式查询
- 避免链式索引：用loc修改数据

**记住**：
- loc用标签，iloc用位置
- loc切片包含两端，iloc不包含末端
- 布尔条件用`&`、`|`、`~`，加括号
- 修改数据用loc，避免链式索引
- 代码清晰比简洁重要

祝你学习愉快，数据分析之路越走越顺！
